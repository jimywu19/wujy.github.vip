[{"id":0,"href":"/posts/awk/","title":"Awk","parent":"Posts","content":"这个来解释下\nss -n |awk \u0026#39;/^tcp/ {++S[$NF]} END {for (a in S) print a, S[a]}\u0026#39;   /^tcp/ 正则表达式，匹配行首以tcp开始\n  NF 列数\n  $NF 最后一列的值，一般是IP地址\n  S[$NF] 下标为具体IP地址的数组,值是数量\n  ++$[$NF] 会把每个IP出现的次数统计出来\n  for (a in S) 这里a取得是S这个数组的下标，就是IP\n  S[a] 也就是统计的数量\n  "},{"id":1,"href":"/","title":"Jimywu's Hugo Site","parent":"","content":""},{"id":2,"href":"/posts/","title":"Posts","parent":"Jimywu's Hugo Site","content":""},{"id":3,"href":"/life/","title":"Lives","parent":"Jimywu's Hugo Site","content":""},{"id":4,"href":"/life/%E4%B8%8D%E7%A1%AE%E5%AE%9A/","title":"不确定","parent":"Lives","content":"不确定性，大部分人都是期盼生活中的不确定性，好听点也可以叫惊喜。\n"},{"id":5,"href":"/python/python/","title":"Python","parent":"Pythons","content":"===\n 本手册是 Python cheat sheet 的中文翻译版。原作者：Arianne Colton and Sean Chen(data.scientist.info@gmail.com) 编译：ucasFL  目录      常规 数值类类型 数据结构 函数 控制流 面向对象编程 常见字符串操作 异常处理 列表、字典以及元组的推导表达式 单元测试  常规      Python 对大小写敏感 Python 的索引从 0 开始 Python 使用空白符（制表符或空格）来缩进代码，而不是使用花括号  获取帮助      获取主页帮助：help() 获取函数帮助：help(str.replace) 获取模块帮助：help(re)  模块(库)     Python的模块只是一个简单地以 .py 为后缀的文件。\n 列出模块内容：dir(module1) 导入模块：import module 调用模块中的函数：module1.func1()   注：import语句会创建一个新的命名空间(namespace)，并且在该命名空间内执行.py文件中的所有语句。如果你想把模块内容导入到当前命名空间，请使用from module1 import *语句。\n 数值类类型     查看变量的数据类型：type(variable)\n六种经常使用的数据类型       int/long：过大的 int 类型会被自动转化为 long 类型\n  float：64 位，Python 中没有 double 类型\n  bool：真或假\n  str：在 Python 2 中默认以 ASCII 编码，而在 Python 3 中默认以 Unicode 编码\n  字符串可置于单/双/三引号中\n  字符串是字符的序列，因此可以像处理其他序列一样处理字符串\n  特殊字符可通过 \\ 或者前缀 r 实现：\nstr1 = r\u0026#39;this\\f?ff\u0026#39;   字符串可通过多种方式格式化：\ntemplate = \u0026#39;%.2f%shaha $%d\u0026#39;; str1 = template % (4.88, \u0026#39;hola\u0026#39;, 2)     NoneType(None)：Python “null”值（None对象只存在一个实例）\n  None不是一个保留关键字，而是NoneType的一个唯一实例\n  None通常是可选函数参数的默认值：\ndef func1(a, b, c=None)   None的常见用法：\nif variable is None :     datetime：Python内置的datetime模块提供了datetime、data以及time类型。\n datetime组合了存储于date和time中的信息  # 从字符串中创建 datetime dt1 = datetime.strptime(\u0026#39;20091031\u0026#39;, \u0026#39;%Y%m%d\u0026#39;) # 获取 date 对象 dt1.date() # 获取 time 对象 dt1.time() # 将 datetime 格式化为字符串 dt1.strftime(\u0026#39;%m/%d/%Y%H:%M\u0026#39;) # 更改字段值 dt2 = dt1.replace(minute=0, second=30) # 做差, diff 是一个 datetime.timedelta 对象 diff = dt1 - dt2    注：\n str、bool、int和float同时也是显式类型转换函数。 除字符串和元组外，Python 中的绝大多数对象都是可变的。   数据结构      注：所有的“非只读(non-Get)”函数调用，比如下面例子中的list1.sort()，除非特别声明，都是原地操作(不会创建新的对象)。\n 元组     元组是 Python 中任何类型的对象的一个一维、固定长度、不可变的序列。\n# 创建元组 tup1 = 4, 5, 6 tup1 = (6, 7, 8) # 创建嵌套元组 tup1 = (4, 5, 6), (7, 8) # 将序列或迭代器转化为元组 tuple([1, 0, 2]) # 连接元组 tup1 + tup2 # 解包元组 a, b, c = tup1 元组应用：\n# 交换两个变量的值 a, b = b, a 列表     列表是 Python 中任何类型的对象的一个一维、非固定长度、可变（比如内容可以被修改）的序列。\n# 创建列表 list1 = [1, \u0026#39;a\u0026#39;, 3] list1 = list(tup1) # 连接列表 list1 + list2 list1.extend(list2) # 追加到列表的末尾 list1.append(\u0026#39;b\u0026#39;) # 插入指定位置 list1.insert(PosIndex, \u0026#39;a\u0026#39;) # 反向插入，即弹出给定位置的值/删除 ValueAtIdx = list1.pop(PosIndex) # 移除列表中的第一个值, a 必须是列表中第一个值 list1.remove(\u0026#39;a\u0026#39;) # 检查成员 3 in list1 =\u0026gt; True or False # 对列表进行排序 list1.sort() # 按特定方式排序 list1.sort(key=len) # 按长度排序   使用 + 连接列表会有比较大的开支，因为这个过程中会创建一个新的列表，然后复制对象。因此，使用extend()是更明智的选择。 insert和append相比会有更大的开支（时间/空间）。 在列表中检查是否包含一个值会比在字典和集合中慢很多，因为前者需要进行线性扫描，而后者是基于哈希表的，所以只需要花费常数时间。   内置的bisect模块       对一个排序好的列表进行二分查找或插入\n  bisect.bisect找到元素在列表中的位置，bisect.insort将元素插入到相应位置。\n  用法：\nimport bisect list1 = list(range(10)) #找到 5 在 list1 中的位置，从 1 开始，因此 position = index + 1 bisect.bisect(list1, 5) #将 3.5 插入 list1 中合适位置 bisect.insort(list1, 3.5)    注：bisect 模块中的函数并不会去检查列表是否排序好，因为这会花费很多时间。所以，对未排序好的列表使用这些函数也不会报错，但可能会返回不正确的结果。\n 针对序列类型的切片      序列类型包括str、array、tuple、list等。\n 用法：\nlist1[start:stop] # 如果使用 step list1[start:stop:step]  注：\n 切片结果包含 start 索引，但不包含 stop 索引 start/stop 索引可以省略，如果省略，则默认为序列从开始到结束，如 list1 == list1[:] 。   step 的应用：\n# 取出奇数位置的元素 list1[::2] # 反转字符串 str1[::-1] 字典（哈希表）     # 创建字典 dict1 = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, 2: [3, 2]} # 从序列创建字典 dict(zip(KeyList, ValueList)) # 获取/设置/插入元素 dict1[\u0026#39;key1\u0026#39;] dict1[\u0026#39;key1\u0026#39;] = \u0026#39;NewValue\u0026#39; # get 提供默认值 dict1.get(\u0026#39;key1\u0026#39;, DefaultValue) # 检查键是否存在 \u0026#39;key1\u0026#39; in dict1 # 获取键列表 dict1.keys() # 获取值列表 dict1.values() # 更新值 dict1.update(dict2) # dict1 的值被 dict2 替换   如果键不存在，则会出现 KeyError Exception 。 当键不存在时，如果 get()不提供默认值则会返回 None 。 以相同的顺序返回键列表和值列表，但顺序不是特定的，也就是说极大可能非排序。   有效字典键类型      键必须是不可变的，比如标量类型(int、float、string)或者元组（元组中的所有对象也必须是不可变的）。 这儿涉及的技术术语是“可哈希(hashability)”。可以用函数hash()来检查一个对象是否是可哈希的，比如 hash('This is a string')会返回一个哈希值，而hash([1,2])则会报错（不可哈希）。  集合       一个集合是一些无序且唯一的元素的聚集；\n  你可以把它看成只有键的字典；\n# 创建集合 set([3, 6, 3]) {3, 6, 3} # 子集测试 set1.issubset(set2) # 超集测试 set1.issuperset(set2) # 测试两个集合中的元素是否完全相同 set1 == set2   集合操作\n 并（或）：set1 | set2 交（与）：set1 \u0026amp; set2 差：set1 - set2 对称差（异或）：set1 ^ set2    函数     Python 的函数参数传递是通过引用传递。\n  基本形式\ndef func1(posArg1, keywordArg1=1, ..)  注：\n 关键字参数必须跟在位置参数的后面； 默认情况下，Python 不会“延迟求值”，表达式的值会立刻求出来。     函数调用机制\n 所有函数均位于模块内部作用域。见“模块”部分。 在调用函数时，参数被打包成一个元组和一个字典，函数接收一个元组args和一个字典kwargs，然后在函数内部解包。    “函数是对象”的常见用法：\ndef func1(ops = [str.strip, user_define_func, ..], ..):  for function in ops:  value = function(value)   返回值       如果函数直到结束都没有return语句，则返回None。\n  如果有多个返回值则通过一个元组来实现。\nreturn (value1, value2) value1, value2 = func1(..)   匿名函数（又称 LAMBDA 函数）       什么是匿名函数？\n匿名函数是一个只包含一条语句的简单函数。\nlambda x : x * 2 # def func1(x) : return x * 2   匿名函数的应用：“柯里化(curring)”，即利用已存在函数的部分参数来派生新的函数。\nma60 = lambda x : pd.rolling_mean(x, 60)   一些有用的函数（针对数据结构）       Enumerate 返回一个序列(i, value)元组，i 是当前 item 的索引。\nfor i, value in enumerate(collection):  应用：创建一个序列中值与其在序列中的位置的字典映射（假设每一个值都是唯一的）。    Sorted 可以从任意序列中返回一个排序好的序列。\nsorted([2, 1, 3]) =\u0026gt; [1, 2, 3]   应用：\nsorted(set(\u0026#39;abc bcd\u0026#39;)) =\u0026gt; [\u0026#39; \u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] # 返回一个字符串排序后无重复的字母序列     Zip 函数可以把许多列表、元组或其他序列的元素配对起来创建一系列的元组。\nzip(seq1, seq2) =\u0026gt; [(\u0026#39;seq1_1\u0026#39;, \u0026#39;seq2_1\u0026#39;), (..), ..]   zip()可以接收任意数量的序列作为参数，但是产生的元素的数目取决于最短的序列。\n  应用：多个序列同时迭代：\nfor i, (a, b) in enumerate(zip(seq1, seq2)):   unzip：另一种思考方式是把一些行转化为一些列：\nseq1, seq2 = unzip(zipOutput)     Reversed 将一个序列的元素以逆序迭代。\nlist(reversed(range(10)))  reversed() 会返回一个迭代器，list() 使之成为一个列表。\n   控制流       用于 if-else 条件中的操作符：\nvar1 is var2 # 检查两个变量是否是相同的对象  var1 is not var2 # 检查两个变量是否是不同的对象  var1 == var2 # 检查两个变量的值是否相等  注：Python 中使用 and、or、not 来组合条件，而不是使用 \u0026amp;\u0026amp;、||、! 。\n   for循环的常见用法：\nfor element in iterator: # 可迭代对象（list、tuple）或迭代器  pass  for a, b, c in iterator: # 如果元素是可以解包的序列  pass   pass：无操作语句，在不需要进行任何操作的块中使用。\n  三元表达式，又称简洁的 if-else，基本形式：\nvalue = true-expr if condition else false-expr   Python 中没有 switch/case 语句，请使用 if/elif。\n  面向对象编程       对象是 Python 中所有类型的根。\n  万物（数字、字符串、函数、类、模块等）皆为对象，每个对象均有一个“类型(type)”。对象变量是一个指向变量在内存中位置的指针。\n  所有对象均会被引用计数。\nsys.getrefcount(5) =\u0026gt; x a = 5, b = a # 上式会在等号的右边创建一个对象的引用，因此 a 和 b 均指向 5 sys.getrefcount(5) =\u0026gt; x + 2 del(a); sys.getrefcount(5) =\u0026gt; x + 1   类的基本形式：\nclass MyObject(object):  # \u0026#39;self\u0026#39; 等价于 Java/C++ 中的 \u0026#39;this\u0026#39;  def __init__(self, name):  self.name = name  def memberFunc1(self, arg1):  pass  @staticmethod  def classFunc2(arg1):  pass obj1 = MyObject(\u0026#39;name1\u0026#39;) obj1.memberFunc1(\u0026#39;a\u0026#39;) MyObject.classFunc2(\u0026#39;b\u0026#39;)   有用的交互式工具：\ndir(variable1) # 列出对象的所有可用方法   常见字符串操作     # 通过分隔符连接列表/元组 \u0026#39;, \u0026#39;.join([ \u0026#39;v1\u0026#39;, \u0026#39;v2\u0026#39;, \u0026#39;v3\u0026#39;]) =\u0026gt; \u0026#39;v1, v2, v3\u0026#39;  # 格式化字符串 string1 = \u0026#39;My name is {0}{name}\u0026#39; newString1 = string1.format(\u0026#39;Sean\u0026#39;, name =　\u0026#39;Chen\u0026#39;)  # 分裂字符串 sep = \u0026#39;-\u0026#39;; stringList1 =　string1.split(sep)  # 获取子串 start = 1; string1[start:8]  # 补 \u0026#39;0\u0026#39; 向右对齐字符串 month = \u0026#39;5\u0026#39;; month.zfill(2) =\u0026gt; \u0026#39;05\u0026#39; month = \u0026#39;12\u0026#39;; month.zfill(2) =\u0026gt; \u0026#39;12\u0026#39; month.zfill(3) =\u0026gt; \u0026#39;012\u0026#39; 异常处理       基本形式：\ntry:  pass except ValueError as e:  print e except (TypeError, AnotherError):  pass except:  pass finally:  pass # 清理，比如 close db;   手动引发异常：\nraise AssertionError # 断言失败 raise SystemExit # 请求程序退出 raise RuntimeError(\u0026#39;错误信息 :..\u0026#39;)   列表、字典以及元组的推导表达式     使代码更加易读易写的语法糖。\n  列表推导\n  用一个简练的表达式，通过筛选一个数据集并且转换经过筛选的元素的方式来简明地生成新列表。\n  基本形式：\n[expr for val in collection if condition]   等价于\nresult = [] for val in collection:  if condition:  result.append(expr) 可以省略过滤条件，只留下表达式。\n  字典推导\n  基本形式：\n{key-expr : value-expr for value in collection if condition}     集合推导\n 基本形式：和列表推导一样，不过是用 () 而不是 [] 。    嵌套列表\n  基本形式：\n[expr for val in collection for innerVal in val if condition]     单元测试     Python自带unittest模块，可供我们编写单元测试。\nimport unittest 我们可以编写继承于unittest.TestCase测试类的子类，并在子类中编写具体的测试函数。测试函数命必须以test_开头，否则不会被识别为测试函数，进而不会在运行单元测试时被运行。\nclass TestSubclass(unittest.TestCase):   def test_func(self):  self.assertEqual(0, 0)  # 可以通过msg关键字参数提供测试失败时的提示消息  self.assertEqual(0, 0, msg=\u0026#39;modified message\u0026#39;)  self.assertGreater(1, 0)  self.assertIn(0, [0])  self.assertTrue(True)  # 测试是否会抛出异常  with self.assertRaises(KeyError):  _ = dict()[1]   # 被@unittest.skip装饰器装饰的测试类或测试函数会被跳过  @unittest.skip(reason=\u0026#39;just skip\u0026#39;)  def test_skip(self):  raise Exception(\u0026#39;I shall never be tested\u0026#39;) 另外，unittest.TestCase中还有两个特殊的成员函数，他们分别会在调用每一个测试函数的前后运行。在测试前连接数据库并在测试完成后断开连接是一种常见的使用场景。\ndef setUp(self):  # To do: connect to the database  pass  def tearDown(self):  # To do: release the connection  pass  def test_database(self):  # To do: test the database  pass 测试类编写完毕后，可以通过添加以下代码来将当前文件当成正常的Python脚本使用\nif __name__ == \u0026#39;__main__\u0026#39;:  unittest.main() "},{"id":6,"href":"/python/","title":"Pythons","parent":"Jimywu's Hugo Site","content":""},{"id":7,"href":"/python/a_bit_of_python/","title":"A_bit_of_python","parent":"Pythons","content":"0. 前言     A Bite of Python，也可叫作“咬一口Python”，寓意着Python的冰山一角，包含着作者这几年学Python时积累的一些知识和经验，文章中包含了许多快速简洁的例子，方便让读者了解到Python中存在的一些概念，然后去自行拓展。\n1. 基础     Python是一门解释型的高级编程语言，由Guido van Rossum于1989年开始编写，并在1991年发布了第一版。Python的特点是代码简洁而且可读性强，使用空格缩进来划分代码块。\n1.0 安装     用浏览器访问官网的下载页面Download Python，选择合适的版本下载安装。\n命令行安装：\nMac:\n$ brew install python3 Debian\u0026amp;Ubuntu:\n$ sudo apt-get install python3 1.1 解释器     Python的官方解释器是CPython，也就是我们通常讨论的Python的实现，它是用C编写的，负责将编写好的Python代码翻译并执行。\n除此之外，Python还有许多实现版本：\n PyPy，用rPython实现的Python解释器，使用了JIT编译技术，因此执行速度通常比C实现的CPython还要快。 Jython，一个用Java实现的Python解释器。 IronPython，一个用.NET实现的Python解释器。  1.2 语法     1.2.0 缩进     不同于一些语言使用花括号的方式来明确代码块，Python用缩进来表示代码的层级（通常是四个空格，最好不要用tab）\nx = 75 if x \u0026gt;= 60:  if x \u0026gt; 80:  print(\u0026#39;A\u0026#39;)  else:  print(\u0026#39;B\u0026#39;) else:  print(\u0026#39;C\u0026#39;) # 75 1.2.1 布尔运算        运算 结果     x or y 如果 x 是false, 就是y, 否则是 x   x and y 如果 x 是false, 就是x, 否则是 y   not x 如果 x 是false, 就是True, 否则是 False    1.2.2 比较运算        运算 含义     \u0026lt; 小于   \u0026lt;= 小于或等于   \u0026gt; 大于   \u0026gt;= 大于等于   == 等于   != 不等于   is 对象标识等于   is not 对象标识不等于    1.2.3 数值操作        运算 含义     x + y 加法   x - y 减法   x * y 乘法   x / y 除法   x // y 整除   x % y 取模   -x 取反   +x 取正   abs(x) 绝对值   int(x) 整型转换   float(x) 浮点数转换   complex(re, im) 复数   c.conjugate() 共轭复数   divmod(x, y) 返回(x // y, x % y)   pow(x, y) x的y次幂   x ** y x的y次幂    1.2.4 位运算        运算 含义     `x y`   x ^ y 按位异或   x \u0026amp; y 按位与   x \u0026lt;\u0026lt; n 按位左移   x \u0026gt;\u0026gt; n 按位右移   ~x 按位反转    1.3 关键字     True-False     True和False分别表示Python布尔值中的真和假，当用==比较时，1与True相等，0与False相等，因此True和False还可以当作索引应用在容器操作上。\n用内置的bool函数可以返回一个对象的布尔值表示，通常一个空的容器（例如一个空列表、一个空字典）的布尔值表示会返回False，反之为True，此外None的布尔值表示也是为False。\ntype(False), type(True) # \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt;  0 == False, 1 == True # True True  0 is False, 1 is True # False False  [1,2,3][False], [1,2,3][True] # 1 2  bool([]), bool({}), bool(set()), bool(()), bool(\u0026#39;\u0026#39;), bool(None) # False False False False False False None     None在Python中表示空或不存在的含义，在同一个运行的程序中，None的地址只有一个。\n当一个函数没有执行return语句或者执行一个没有返回对象的return语句时，默认会返回None值。\ntype(None) # \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt;  id(None) == id(None) # True  def f():  a = 1  def f2():  a = 1  return  f() # None f2() # None not     not在Python中常用于逻辑判断，表示非或不的含义，当not应用在布尔值时，会把布尔值取反返回，否则会尝试将对象转成布尔值表示再进行逻辑操作。\nnot False not True not None not [], not {}, not (), not set() # True # False # True # True True True True not一般也应用于判断一个对象是否存在于容器上：\n1 not in (1, 2, 3) # False 1 not in [1, 2, 3] # False \u0026#39;a\u0026#39; not in {\u0026#39;a\u0026#39;: 1} # False \u0026#39;a\u0026#39; not in {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;} 还有用于对象的标识判断：\na = \u0026#39;None\u0026#39; a is not None # True is     is用于判断是否同一个对象：\nTrue is True True is not True # True # False  sentinel = object() l = [] l.append(object()) l.append(sentinel) l.append(object()) for obj in sentinel  print(\u0026#39;object\u0026#39;)  if obj is sentinel:  break # object A simple life lesson：\nimport this # ... love = this this is love # True love is True # False love is False # False love is not True or False # True love is not True or False; love is love # True and     and表示与的关系，用在条件表达式时，表示只有两个条件同时成立的情况下，判断条件才成功。\nTrue and False True and True False and False False and True # False # True # False # False 当用and来连接两个表达式时，根据短路性质，如果第一个表达式的布尔表示为False，那么不会计算后面的表达式。\ndef condition_true():  print(\u0026#34;true\u0026#34;)  return True  def condition_false():  print(\u0026#34;false\u0026#34;)  return False  if condition_true() and condition_false():  pass # true # false  if condition_false() and condition_true():  pass # false  if condition_true() and condition_true():  pass # true # true or     or表示或的关系，用在条件表达式时，表示如果有其中一个条件成立的情况下，则判断条件成功。\nTrue or False True or True False or False False or True # True # True # False # True 当用or来连接两个表达式时，根据短路性质，如果第一个表达式的布尔表示为True，那么不会计算后面的表达式。\ndef condition_true():  print(\u0026#34;true\u0026#34;)  return True  def condition_false():  print(\u0026#34;false\u0026#34;)  return False  if condition_true() or condition_false():  pass # true  if condition_false() or condition_true():  pass # false # true  if condition_true() or condition_true():  pass # true  None or [] None or [] or {} None or [] or {} # [] # {} def     def用于定义一个函数或方法，后面跟着的是函数名，以及参数列表。\ndef f():  print(\u0026#34;f\u0026#34;) f() # f  def f():  print(\u0026#34;f\u0026#34;)  def f2():  print(\u0026#34;f2\u0026#34;)  return f2 f2 = f() f2() # f # f2 在定义类的实例方法时，函数参数列表的第一个参数代表着类实例本身：\nclass Func:  def f(self):  print(\u0026#34;f\u0026#34;)  return self.f2   def f2(self):  print(\u0026#34;f2\u0026#34;) f2 = Func().f() f2() # f # f2 pass     pass在Python中不做任何事情，通常用pass是为了保持程序结构的完整性，例如提前定义一个稍后实现的函数，或者继承一个基类但不重写其中的方法（常见于自定义异常）等等。\ndef f():  pass  class MyException(Exception):  pass import     import语句在Python中的作用是导入其他模块，籍此访问其他模块中的变量。\nimport sys sys.version_info # sys.version_info(major=3, minor=6, micro=1, releaselevel=\u0026#39;final\u0026#39;, serial=0) 导入又分为绝对导入和相对导入，其中import \u0026lt;\u0026gt;属于绝对导入，相对导入一般用from \u0026lt;\u0026gt; import的方式。\nfrom     from语句用来从一个模块中导入变量。\nfrom sys import version_info version_info # sys.version_info(major=3, minor=6, micro=1, releaselevel=\u0026#39;final\u0026#39;, serial=0) 相对导入一般可以用from \u0026lt;\u0026gt; import的语法来完成，在PEP 328中有一个例子，假设当前的目录结构如下：\npackage/ __init__.py subpackage1/ __init__.py moduleX.py moduleY.py subpackage2/ __init__.py moduleZ.py moduleA.py 而当前文件是moduleX.py或者subpackage1/__init__.py，以下的相对导入的语法都是合法的：\nfrom .moduleY import spam from .moduleY import spam as ham from . import moduleY from ..subpackage1 import moduleY from ..subpackage2.moduleZ import eggs from ..moduleA import foo from ...package import bar as     在导入模块时可以给模块起别名，而这个操作一般可以用as关键字来实现：\nimport abc as cba cba # \u0026lt;module \u0026#39;abc\u0026#39; from \u0026#39;/usr/local/Cellar/python3/3.6.1/bin/../Frameworks/Python.framework/Versions/3.6/lib/python3.6/abc.py\u0026#39;\u0026gt; assert     assert语句用于实现表达式的断言，如果断言没有通过，则会抛出一个AsserationError异常：\nassert 1+1 == 2 assert 1+1 == 3, \u0026#34;1+1=2!\u0026#34; # AssertionError: 1+1=2! for     for语句用于对一个可迭代对象执行遍历操作，需与in配合使用。\nfor i in range(3):  print(i) # 0 # 1 # 2  for i in \u0026#34;abc\u0026#34;:  print(i) # a # b # c  [i for i in reversed(\u0026#34;abc\u0026#34;)] # [\u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;] break     break用于中断当前循环体的执行，跳出当前循环。\nwhile True:  print(1)  break  print(2) # 1  for i in range(5):  if i == 3:  break  print(i) # 0 # 1 # 2 continue     continue用于跳过当前的循环体的一个迭代。\nfor i in range(5):  if i == 3:  continue  print(i) # 0 # 1 # 2 # 4 class     class用于类的定义。\nclass Counter:  base = 0   def __init__(self):  self.c = self.base   def add(self, i):  self.c += i  return self.c  c = Counter() c.add(1) c.add(1) Counter.base = 5 c.add(1) Counter().add(1) # 1 # 2 # 3 # 6 在类层级定义的属性或者方法都会绑定到类的__dict__属性上，而每个实例则有自身的__dict__属性，存放实例的属性。\n__dict__属性是一个字典，键为变量的名称，值则是对于的变量值。\nCounter.__dict__ # mappingproxy({\u0026#39;__dict__\u0026#39;: \u0026lt;attribute \u0026#39;__dict__\u0026#39; of \u0026#39;Counter\u0026#39; objects\u0026gt;, # \u0026#39;__doc__\u0026#39;: None, # \u0026#39;__init__\u0026#39;: \u0026lt;function __main__.Counter.__init__\u0026gt;, # \u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, # \u0026#39;__weakref__\u0026#39;: \u0026lt;attribute \u0026#39;__weakref__\u0026#39; of \u0026#39;Counter\u0026#39; objects\u0026gt;, # \u0026#39;add\u0026#39;: \u0026lt;function __main__.Counter.add\u0026gt;, # \u0026#39;base\u0026#39;: 0}) Counter().__dict__ # {\u0026#39;c\u0026#39;: 0} vars(Counter()) # 等于 Counter().__dict__ # {\u0026#39;c\u0026#39;: 0} del     del语句用来删除一个变量的引用，也可以用于容器上的删除操作。\n在这个例子中，当执行del a操作后，下面的print(a)语句就会因为无法访问到a这个变量而抛出异常了。\na = 1 del a  try:  print(a) except NameError:  print(\u0026#34;no variable named a!\u0026#34;) # no variable named a! 除此之外，del也可以用于容器元素或对象属性的删除操作。\nl = [1, 2, 3] del l[1] l # [1, 3]  a = {  \u0026#34;a\u0026#34;: 1,  \u0026#34;b\u0026#34;: 2 } del a[\u0026#34;a\u0026#34;] \u0026#34;a\u0026#34; in a # False  class MyClass:  def __init__(self):  self.i = 1  my_class = MyClass() hasattr(my_class, \u0026#34;i\u0026#34;) # True  del my_class.i hasattr(my_class, \u0026#34;i\u0026#34;) # False if-elif-else     if，elif和else关键字组成程序中的条件语句和控制流。\nfor i in [1, 2, 3]:  if i == 3:  print(\u0026#34;if\u0026#34;)  elif i == 2:  print(\u0026#34;elif\u0026#34;)  else:  print(\u0026#34;else\u0026#34;) # else # elif # if try-raise-except-finally     try，raise，except和finally关键字用于处理和控制程序的异常。\nfor i in [-1, 0, 1]:  try:  if i == -1:  raise ValueError  if i == 0:  raise Exception  except ValueError:  print(\u0026#34;ValueError\u0026#34;)  except Exception:  print(\u0026#34;Exception\u0026#34;)  finally:  print(\u0026#34;i=\u0026#34;, i) # ValueError # i= -1 # Exception # i= 0 # i= 1 lambda     lambda语句用于定义一个匿名函数，函数内容为单个表达式，表达式的值就是lambda函数的返回值。\nadd = lambda a, b: a+b add(1,2) # 3  class ObjectFactory:  create = lambda : object()  ObjectFactory.create() # \u0026lt;object object at 0x108074100\u0026gt; yield     当一个函数中出现了yield关键字时，这个函数就变成了一个生成器，调用这个函数时会返回一个generator对象，接下来可以用next函数来驱动这个生成器往下执行，直至碰到一个yield语句，这时候生成器会返回函数yield语句后面的对象，也可以调用生成器的send方法给生成器发送一个值，这个发送的值会成为yield语句的返回值，当生成器执行完最后一个yield语句后，此时继续驱动生成器就会抛出一个StopIteration的异常，生成器的return语句的返回值会赋值给这个异常实例的value属性上。\ndef g():  a = yield 1  b = yield a  yield b  return \u0026#34;done\u0026#34;  g = g() g # \u0026lt;generator object g at 0x101d4c990\u0026gt; next(g) # equals to `g.send(None)`, variable a will become a `None` # 1 g.send(2) # 2 next(g) # None try:  next(g) except StopIteration as e:  print(e.value)  # done global     如果函数内想对一个全局作用域的变量进行赋值时，则需要用global关键字来声明你想要接触的变量名，接下来便可以访问和修改这个变量。\na = 1  def g():  global a  a = 2  a g() a # 1 # 2 nonlocal     要理解nonlocal关键字，可以看以下的例子。\n在这个例子中，内层函数inside想要修改外层函数变量a的值，但执行outside函数后返回的结果为1。\ndef outside():  a = 1  def inside():  a = 2  inside()  return a  outside() # 1 原因是在执行inside函数时的a = 2语句时，程序认为a是inside函数中的一个局部变量，因此外层函数的变量a没有受到影响。\n解决方法是在a = 2语句之前用nonlocal来声明a不是一个局部变量，这样inside在执行时就会去外层函数寻找名称为a的变量，并对这个值进行修改。\ndef outside():  a = 1  def inside():  nonlocal a  a = 2  inside()  return a outside() # 2 with     with语句需要配合上下文管理器来使用，上下文管理器是一个定义了进入和离开操作的对象，当执行到with语句时，程序就会触发跟随with语句后面的上下文管理器的进入回调，当离开with包裹的区块后，程序就会触发上下文管理器的离开回调。\n这常见于一些资源获取和资源释放的动作，例如下面是一个打开文件的例子，当不用with语句时，需要手动控制文件的关闭，而用with的话，即保证了代码的整洁的同时也确保了可读性。\nf = open(\u0026#34;/etc/hosts\u0026#34;) f.readline() f.close()  with open(\u0026#34;/etc/hosts\u0026#34;) as f:  f.readline() 想定义一个上下文管理器十分简单，只需要编写一个类，并定义其中的__enter__（对应进入）和__exit__（对应离开）方法就可以了。\nclass Context:  def __enter__(self):  print(\u0026#34;__enter__\u0026#34;)  return self   def __exit__(self, exc_type, exc_val, exc_tb):  print(\u0026#34;__exit__\u0026#34;)  with Context() as ctx:  ctx # __enter__ # \u0026lt;__main__.Context object at 0x10dab5438\u0026gt; # __exit__ 1.4 注释     定义注释有两种方式，一种是以\u0026quot;#\u0026ldquo;开头，这种属于是单行注释，另一种是用三个引号包裹字符串，这种可以用作多行注释，也有一种用法是定义函数或类的文档字符串。\n\u0026#39;\u0026#39;\u0026#39; multiple lines comment \u0026#39;\u0026#39;\u0026#39; a = 1  # single line comment b = 2  class C:  \u0026#39;\u0026#39;\u0026#39; This is doc-string \u0026#39;\u0026#39;\u0026#39;  pass  print(repr(C.__doc__)) #\u0026#39; This is doc-string\\n \u0026#39; 1.5 对象模型     要理解Python中的变量首先要明白Python中的命名空间。在Python中，命名空间本质上就是名字到对象的一个映射，因此我们平时谈论的变量也是由名字以及对象两个部分来组成，当执行a = 1这条语句时，Python会在命名空间中添加a这个名字，并把这个名字绑定到1上面，当执行print(a)这条语句时，Python则会从命名空间中查找a这个名字，再把这个名字映射的对象取出来完成后面的动作。\n例如下面这个例子中就很好的展示了Python的对象是如何组织起来的：\nconstant = 1 boolean = True  l = [1,2,3, [4, [5]]] s = l[2:] d = {\u0026#34;l\u0026#34;: l}  def add(a, b):  return a + b add(1,2)  class Link:  def __init__(self, obj):  self.obj = obj  link = Link([1]) type_of_link = type(link) type_of_Link = type(Link) 在Python中万物皆对象，所有的类都继承自object类。\nisinstance(1, object) # True isinstance(\u0026#39;1\u0026#39;, object) # True isinstance([1], object) # True class A: pass isinstance(A, object) # True isinstance(object, object) # True isinstance(object(), object) # True 用type函数能获取对象的类型，例如一个列表的类型是list，类A的实例的类型是__main__.A类，而这个类的类型是type，反而言之，类是type的一个实例。\ntype([]) # list type(A()) # __main__.A type(type(A())) # type 再来看一下看似奇怪的例子：\nisinstance(type, object) # True isinstance(object, type) # True 通过上面这个例子可以看到，type是一个object，object又是一个type，这是什么回事呢？\n其实，type和object有点类似先有鸡还是先有蛋的情况，通过下面这个例子和图解，便能很好的理解type和object之间的关系。首先万物皆object，而type也是继承自object的，但object是type的一个实例，假如我们编写了一个列表，那么这个列表实际上是list的一个实例，list继承了object，而list和object都属于type的实例，这种创造类的类我们也一般称它为元类（metaclasses）。\nobj = object() cobj = C() mylist = [1,2,3] 再来一个例子表明它们之间的关系：\nissubclass(type, object) # type继承了object # True issubclass(object, type) # False isinstance(object, type) # object是type的一个实例 # True isinstance(type, object) # 因为type继承了object，所以这里为True # True 1.6 执行过程     Python代码是如何一步步地转化成Python虚拟机所能理解的形式呢？简单地说，从Python代码转换成字节码的过程中会经过以下的几个过程：\n 把Python源码转换成解析树。 把解析树转换成抽象语法树(AST)。 生成符号表。 从AST中生成codeobject:  把AST转换为控制流 从控制流中提交codeobject    Python中有个内置的compile函数，可以将源代码转换成codeobject，codeobject中包含了源代码转译后的字节码。\ncompile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1) 其中flags指明了编译的特征，例如ast模块的parse函数就把flags设置为PyCF_ONLY_AST。\ncompile(source, filename, mode, PyCF_ONLY_AST) 1.6.1 解析树     前面说了Python在执行时会把代码转化为解析树，那么解析树长什么样呢？\n下面用parser模块对一个加法函数就行解析，对结果进行打印：\nimport parser from pprint import pprint  code_str = \u0026#39;def add(a, b):return a + b\u0026#39; res = parser.suite(code_str) pprint(res.tolist()) 不难看出，这个结果列表是一个树状结构：\n[257, [269, [295, [263, [1, \u0026#39;def\u0026#39;], [1, \u0026#39;add\u0026#39;], [264, [7, \u0026#39;(\u0026#39;], [265, [266, [1, \u0026#39;a\u0026#39;]], [12, \u0026#39;,\u0026#39;], [266, [1, \u0026#39;b\u0026#39;]]], [8, \u0026#39;)\u0026#39;]], [11, \u0026#39;:\u0026#39;], [304, [270, [271, [278, [281, [1, \u0026#39;return\u0026#39;], [331, [305, [309, [310, [311, [312, [315, [316, [317, [318, [319, [320, [321, [322, [323, [324, [1, \u0026#39;a\u0026#39;]]]]]], [14, \u0026#39;+\u0026#39;], [320, [321, [322, [323, [324, [1, \u0026#39;b\u0026#39;]]]]]]]]]]]]]]]]]]]], [4, \u0026#39;\u0026#39;]]]]]], [4, \u0026#39;\u0026#39;], [0, \u0026#39;\u0026#39;]] 但列表里面大部分都是让人看不懂的数字，其实每个数字都代表了一个符号或者令牌，分别象征着不同的含义，它们对应的含义可以在CPython源码的Include/graminit.h和Include/token.h文件中找到。\n下面是对上面列表翻译后的一个树状结构，可以看到原来的代码都被翻译成一颗工整的语法树结构了。\n1.6.2 指令栈     在CPython中，Python的代码最终会被转化成字节码，再由虚拟机对它们进行解析，Python的虚拟机是一种基于栈形式的虚拟机。\n在Python中有一个dis模块可以帮助把字节码转成可读的形式展示，下面这个例子对loop函数进行分析，这个函数循环对一个初始值为1的变量进行累加，直至变量的值等于5。\ndef loop():  x = 1  while x \u0026lt; 5:  x += 1  print(x)  import dis dis.dis(loop) 下面输出的字节码的指令含义都可以在library/dis中找到。\n 2 0 LOAD_CONST 1 (1) 2 STORE_FAST 0 (x) 3 4 SETUP_LOOP 28 (to 34) \u0026gt;\u0026gt; 6 LOAD_FAST 0 (x) 8 LOAD_CONST 2 (5) 10 COMPARE_OP 0 (\u0026lt;) 12 POP_JUMP_IF_FALSE 32 4 14 LOAD_FAST 0 (x) 16 LOAD_CONST 1 (1) 18 INPLACE_ADD 20 STORE_FAST 0 (x) 5 22 LOAD_GLOBAL 0 (print) 24 LOAD_FAST 0 (x) 26 CALL_FUNCTION 1 28 POP_TOP 30 JUMP_ABSOLUTE 6 \u0026gt;\u0026gt; 32 POP_BLOCK \u0026gt;\u0026gt; 34 LOAD_CONST 0 (None) 36 RETURN_VALUE 有了上面的基础，再来看下面这个例子：\nfrom timeit import timeit timeit(\u0026#39;[]\u0026#39;) # 0.027015632018446922 timeit(\u0026#39;list()\u0026#39;) # 0.44922116107773036 timeit(\u0026#39;{}\u0026#39;) # 0.041279405006207526 timeit(\u0026#39;dict()\u0026#39;) # 0.44984785199631006 为什么用[]定义一个列表比用list()定义一个列表要更快呢？用dis模块进行分析后便很容易得出结论了，相比于[]，执行list()时需要去加载list这个名字并查找和调用对应的函数，而执行[]时的指令数量比前者更少，因此它的执行速度也更快。\ndis.dis(\u0026#39;list()\u0026#39;)  1 0 LOAD_NAME 0 (list)  2 CALL_FUNCTION 0  4 RETURN_VALUE dis.dis(\u0026#39;[]\u0026#39;)  1 0 BUILD_LIST 0  2 RETURN_VALUE 访问函数的__code__属性便能获得函数的code对象，code对象包含了这个函数解析后的字节码，使用opcode模块可获取字节码对应的指令。\nimport opcode  def add(a, b):  return a + b  add.__code__.co_code # b\u0026#39;|\\x00|\\x01\\x17\\x00S\\x00\u0026#39; list(add.__code__.co_code) # [124, 0, 124, 1, 23, 0, 83, 0]  for code in list(add.__code__.co_code):  print(opcode.opname[code])  # LOAD_FAST # \u0026lt;0\u0026gt; # LOAD_FAST # POP_TOP # BINARY_ADD # \u0026lt;0\u0026gt; # RETURN_VALUE # \u0026lt;0\u0026gt; 1.7 LEGB     LEGB规则定义了Python对命名空间的查找顺序。\n具体如下：\n Locals 函数内的命名空间 Enclosing 外层函数的命名空间 Globals 所在模块命名空间 Builtins Python内置模块的名字空间  def outside():  v = 2  def inside():  print( # B   v) # E  inside() # L outside() # G globals()\n返回当前作用域的全局变量空间\nlocals()\n返回当前作用域的本地变量空间\n1.8 MRO     MRO决定了Python多继承中的方法解析顺序。\n假如下面的一个类结构，D继承了B和C，B和C分别继承了A。\n代码如下，其中A类和C类拥有方法f，分别打印A和C：\nclass A:  def f(self):  print(\u0026#39;A\u0026#39;)  class B(A): pass class C(A):  def f(self):  print(\u0026#39;C\u0026#39;)  class D(B, C): pass  D().f() 以上的输出在Python 2.7和3.6会有不同的输出，\n其中2.7输出的是：\nA 而3.6输出的是：\nC 导致结果的差异是因为在旧式类（old-style class）和新式类（new-style class）中，MRO的规则有所不同。\n执行以下语句：\nD.__mro__ 可以看到在旧式类中，方法的查找顺序为D-\u0026gt;B-\u0026gt;A-\u0026gt;C：\n而在新式类中，方法的查找顺序为D-\u0026gt;B-\u0026gt;C-\u0026gt;A：\n在Python 3.x出现后，就只保留新式类了，采用的MRO规则为C3算法。\n1.9 自省     dir：返回指定对象的属性列表。\na = [] dir(a) \u0026#39;\u0026#39;\u0026#39; [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__delitem__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__iadd__\u0026#39;, \u0026#39;__imul__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__reversed__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__setitem__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;extend\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;remove\u0026#39;, \u0026#39;reverse\u0026#39;, \u0026#39;sort\u0026#39;] \u0026#39;\u0026#39;\u0026#39; getattr：获取一个对象中的属性，若不存在则抛出AttributeError异常，如果指定了默认值则返回默认值。\nclass A:  pass getattr(A, \u0026#39;a\u0026#39;) # AttributeError: type object \u0026#39;A\u0026#39; has no attribute \u0026#39;a\u0026#39; getattr(A, \u0026#39;a\u0026#39;, 1) # 1 hasattr：检查一个对象是否有指定的属性。\nhasattr(A, \u0026#39;a\u0026#39;) # False setattr：给一个对象的设置属性名和属性名的对应值。\nif not hasattr(A, \u0026#39;a\u0026#39;):  setattr(A, \u0026#39;a\u0026#39;, 2) if hasattr(A, \u0026#39;a\u0026#39;):  getattr(A, \u0026#39;a\u0026#39;) # 2 inspect：一个非常有用的内置模块，能够非常方便的获取对象信息。\nimport inspect inspect.getmembers(a) 1.10 垃圾回收     Python的垃圾回收方式主要包括引用计数法和分代回收法。\n引用计数\nPython的垃圾回收主要依赖基于引用计数的回收算法，当一个对象的引用数为0时，Python虚拟机就会考虑回收对象占用的内存。\n但引用计数的缺点也十分明显，那就是循环引用的问题，试想有两个容器对象，分别引用了对方作为自己的一个属性，这样在删除其中一个变量后，由于其对象还保留着引用，因此它的内存无法被释放。为了解决这个问题，Python使用了mark-sweep算法，定期扫描跟踪对象的引用情况，释放无用对象的内存。\n分代回收\n分代回收算法基于弱代假说的思想，即：相对于存活时间长的对象，GC更加频繁去处理那些年轻的对象。\nPython的分代回收机制把对象按照存活时间分成三个集合，每一个集合即为一个“代”，分别对于一个链表，当垃圾回收器进行收集时，会首先考虑去检查存活时间较短的对象集合。\n1.11 PEP8     PEP8定义了Python代码的风格指南。\n命名风格      b (single lowercase letter) B (single uppercase letter) lowercase lower_case_with_underscores UPPERCASE UPPER_CASE_WITH_UNDERSCORES CapitalizedWords (or CapWords, or CamelCase \u0026ndash; so named because of the bumpy look of its letters [4]). This is also sometimes known as StudlyCaps.  函数/方法参数      实例方法的第一个参数名用self。 类方法的第一个参数名为cls。  行最大长度     一行的最大行宽不能超过79个字符数量，否则需要用反斜杠\u0026rdquo;\u0026quot;结尾将其分成多行。\n导入模块     导入模块时应该注意分行导入：\nYes: import os  import sys \tfrom subprocess import Popen, PIPE  No: import sys, os 异常捕获     捕获异常时要尽量指定其异常类型，否则易导致异常被掩盖等问题。\n# Yes try:  import platform_specific_module except ImportError:  platform_specific_module = None 比较     布尔值比较\n不要用==用于布尔值的比较。\nYes: if greeting: No: if greeting == True: Worse: if greeting is True: None比较\n# Yes if foo is not None  ## No  if foo !== None  # No if not foo is None 类型比较\n# Yes if isinstance(obj, int):  # No if type(obj) is type(1):  PEP 8 - Style Guide for Python Code\n1.12 模块     __name__和__main__\n当Python源文件被解释器执行时，解释器会把__main__赋值给起始模块的__name__，表示这是程序的主入口模块，而当Python源文件被当作模块被其他模块导入时，__name__的赋值则是模块的名称。\n例如现在定义了一个源文件a.py如下：\nprint(__name__) if __name__ == \u0026#39;__main__\u0026#39;:  print(\u0026#39;Hello\u0026#39;) 直接执行：\npython3 a.py # __main__ # Hello 可以看到这时候a.py中的__name__的值是__main__，而现在编写另一个文件b.py，并且把a作为模块导入：\nimport a # a 这时候看到a.py中的__name__的值已经变成了a，因此也不会输出Hello。\n使用if __name__ == '__main__'这种方式可以把模块即能当作模块来使用，也能当作脚本来直接执行，在Python中有几个模块就是采用了这种方式：\npython3 -m http.server python3 -m pip install requests cat test.json | python3 -m json.tool __init__.py和__all__\n在文件夹中定义一个名为__init__.py的文件意思是告诉解释器把目录当成一个Python模块。\n例如现在定义了下面的一个目录：\n├── __init__.py ├── l1.py └── sub_package ├── __init__.py └── l2.py l1.py\nfrom sub_package.l2 import l2_f  l2_f()  from sub_package import l2_f  l2_f() sub_package/_init_.py\nfrom .l2 import l2_f  __all__ = [\u0026#39;l2_f\u0026#39;] sub_package/l2.py\ndef l2_f():  print(\u0026#39;l2\u0026#39;) 执行a.py：\npython3 l1.py # l2 # l2 这两种方式都能导入l2.py中的函数，而在后面的导入方式中，当l1.py试图从sub_package导入一个函数时，它会检查sub_package目录下的__init__.py，而__init__.py把l2.py的函数导入进了自身的命名空间里面，于是l2_f函数可以顺利被l1.py导入。\n__all__指定了模块暴露的接口列表。\n2. 容器     Python包括多种容器数据类型：\n   数据类型 可变 有序     list yes yes   tuple no yes   str no yes   range no yes   bytes no yes   bytearray yes yes   array yes yes   set yes no   frozenset no no   dict yes no   OrderedDict yes yes    鸭子类型     首先看鸭子类型（duck typing）的定义：\n 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。\n Python的容器抽象类也有鸭子类型的体现，看下面这个例子：\nfrom collections.abc import Sized  class A:  def __len__(self):  return 0  len(A()) # 0 issubclass(A, Sized) # use __instancecheck__ # True isinstance(A(), Sized) # use __subclasscheck__ # True 定义了一个类A，并定义了它的__len__方法，这个方法会在调用len函数时被调用到。\nSized是一个collections.abc模块定义的一个容器抽象类，但是A类没有继承Sized类，为什么Python却认为A是Sized的一个子类呢？\n如果仔细看Sized类的定义，它实现了一个__subclasshook__的方法，这个方法会在执行issubclass函数时会被调用，Sized类会检查A是否拥有一个名为__len__的方法，如果拥有则返回True，于是issubclass的调用会返回True。\n这也就体现了，如果A拥有__len__的方法，那么它就是一个Sized。\nclass Sized(metaclass=ABCMeta):   __slots__ = ()   @abstractmethod  def __len__(self):  return 0   @classmethod  def __subclasshook__(cls, C):  if cls is Sized:  if any(\u0026#34;__len__\u0026#34; in B.__dict__ for B in C.__mro__):  return True  return NotImplemented 下图是list与其它容器类之间的关系：\n了解更多抽象容器类可查看collections.abc这个模块。\n2.1 列表     l = [] l.append(1) # [1] l.extend([2, 3]) # [1, 2, 3] l.pop() # [1, 2] l.insert(1, 3) # [1, 3, 2] l.index(1) # 0 l.sort() # [1, 2, 3] l.reverse() # [3, 2, 1] l.count(2) # 1 l.remove(1) # [3, 2] l.clear() # [] 2.2 元组     t = (1, 2) t[0] # 1 t[1] # 2 2.3 字典     d = {} d[\u0026#39;a\u0026#39;] = 1 # {\u0026#39;a\u0026#39;: 1} d.get(\u0026#39;a\u0026#39;) # 1 d.get(\u0026#39;b\u0026#39;) # None d.get(\u0026#39;b\u0026#39;, 2) # 2 d.values() # dict_values([1]) d.keys() # dict_keys([\u0026#39;a\u0026#39;]) d.items() # dict_items([(\u0026#39;a\u0026#39;, 1)]) d.pop(\u0026#39;a\u0026#39;) # 1 d # {} 2.4 集合     s1 = set([1, 2, 3]) s2 = set([3, 4, 5])  s1 - s2 # {1, 2}  s1 \u0026amp; s2 # {3}  s1 | s2 # {1, 2, 3, 4, 5}  s1 ^ s2 # {1, 2, 4, 5} 2.5 字符串     s = \u0026#39;string\u0026#39; b = b\u0026#39;string\u0026#39; b == s # False b == s.encode() # True memoryview(b).to_list() # [115, 116, 114, 105, 110, 103] \u0026#39;-\u0026#39;.join(map(chr, memoryview(s.encode()).tolist())) # \u0026#39;s-t-r-i-n-g\u0026#39; 2.6 双向队列     from collections import deque queue = deque([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]) queue.append(\u0026#34;d\u0026#34;) queue.append(\u0026#34;e\u0026#34;) queue.popleft() # \u0026#39;a\u0026#39; queue.popleft() # \u0026#39;b\u0026#39; queue # deque([\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;]) 2.7 队列     from queue import Queue  q = Queue()  q.put(1)  q.get() # 1  q.empty() # True 3.函数/类     3.1 函数     3.1.1 栈帧     Python通过栈帧来关联函数之间的调用，每次调用函数时，函数的栈帧会放在调用栈上，调用栈的深度随着函数的调用深度增长，栈帧对象包含了函数的code对象，函数的局部变量数据，前一个栈帧和行号等信息。\ndef c():  pass  def b():  pass  def a():  b()  c()  def go():  a()  go() 在下面这个例子中，f函数通过获取调用链中前一个栈帧的信息，拿到add函数栈帧中局部变量a与b的值，使得f函数在不接收参数的情况下完成了透明的加法：\nimport inspect  def f():  current_frame = inspect.currentframe()  back_frame = current_frame.f_back  a = back_frame.f_locals[\u0026#39;a\u0026#39;]  b = back_frame.f_locals[\u0026#39;b\u0026#39;]  return a + b  def add(a, b):  print(f())  add(1, 2) # 3 3.1.2 参数     下面这个函数展示了参数的定义形式：\n a是一个普通参数，调用时必须要指定一个值，否则会报错。 b是一个指定了默认值（None）的参数，如果调用时没有指定值，那么b的值便是None。 args和kwargs分别是一个tuple和dict，它们封装了剩下的可变长参数，其中关键字参数会传递到kwargs上，而非关键字参数会传递到args上。  def f(a, b=None, *args, **kwargs):  print(a)  print(b)  print(args)  print(kwargs)  f(1, 2, 3, 4, keyword=5) # 1 # 2 # (3, 4) # {\u0026#39;keyword\u0026#39;: 5} 要想查看函数的参数签名信息，可使用inspect模块的signature函数，它会返回一个签名类的对象，上面包含了函数的参数名字以及注解等信息。\nimport inspect  def func(f, a: int, b: int):  return f(a, b)  sig = inspect.signature(func) type(sig) # \u0026lt;class \u0026#39;inspect.Signature\u0026#39;\u0026gt; sig.parameters # OrderedDict([(\u0026#39;f\u0026#39;, \u0026lt;Parameter \u0026#34;f\u0026#34;\u0026gt;), (\u0026#39;a\u0026#39;, \u0026lt;Parameter \u0026#34;a:int\u0026#34;\u0026gt;), (\u0026#39;b\u0026#39;, \u0026lt;Parameter \u0026#34;b:int\u0026#34;\u0026gt;)]) sig.parameters.get(\u0026#39;a\u0026#39;).annotation # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 使用functools模块的partial可以将已知值绑定到函数的一个或多个参数上：\nimport operator from functools import partial  def func(f, a: int, b: int):  return f(a, b)  add = partial(func, operator.add) sub = partial(func, operator.sub)  add(1, 2) # 3 sub(1, 2) # -1 3.1.3 装饰器     装饰器是一个函数，它用于给已有函数扩展功能，它通常接收一个函数作为参数，并返回一个新的函数。\n装饰器可配合@符号十分简洁地应用在函数上。\ndef tag(func):  def wrapper(*args, **kwargs):  func_result = func(*args, **kwargs)  return \u0026#39;\u0026lt;{tag}\u0026gt;{content}\u0026lt;/{tag}\u0026gt;\u0026#39;.format(tag=func.__name__, content=func_result)  return wrapper  @tag def h1(text):  return text  @tag def p(text):  return text  def div(text):  return text   html = h1(p(\u0026#39;Hello World\u0026#39;)) print(html) # \u0026lt;h1\u0026gt;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026lt;/h1\u0026gt; html2 = tag(div)(\u0026#39;Hello World\u0026#39;) print(html2) # \u0026lt;div\u0026gt;Hello World\u0026lt;/div\u0026gt; 类装饰器\nclass Tag:  def __init__(self, func):  self.func = func   def __call__(self, *args, **kwargs):  func_result = self.func(*args, **kwargs)  return \u0026#39;\u0026lt;{tag}\u0026gt;{content}\u0026lt;/{tag}\u0026gt;\u0026#39;.format(tag=self.func.__name__, content=func_result)  @Tag def h1(text):  return text  html = h1(\u0026#39;Hello World\u0026#39;) print(html) 3.1.4 生成器     yield能把一个函数变成一个generator，与return不同，yield在函数中返回值时会保存函数的状态，使下一次调用函数时会从上一次的状态继续执行，即从yield的下一条语句开始执行。\ndef fib(max):  n, a, b = 0, 0, 1  while n \u0026lt; max:  yield(b)  a, b = b, a + b  n = n + 1  f = fib(10) next(f) # 1 next(f) # 1 next(f) # 2 f.send(None) # 3 for num in f:  print(num) # 5 # 8 # 13 # 21 # 34 # 55 next(f) # StopIteration 3.2类     3.2.1 可见性     当一个类的方法名前以单下划线或双下滑线开头时，通常表示这个方法是一个私有方法。\n但这只是一种约定俗成的方式，对于外部来说，以单下划线开头的方法依然是可见的，而双下划线的方法则被改写成_类名__方法名存放在名字空间中，所以如果B继承了A，它是访问不到以双下划线开头的方法的。\nclass A:  def public_method(self):  pass   def _private_method(self):  pass   def __private_method(self):  pass  a = A() a.public_method() # None a._private_method() # None a.__private_method() # AttributeError: \u0026#39;A\u0026#39; object has no attribute \u0026#39;__A_private_method\u0026#39; a._A__private_method() # None A.__dict__ # mappingproxy({\u0026#39;_A__private_method\u0026#39;: \u0026lt;function __main__.A.__private_method\u0026gt;, # \u0026#39;__dict__\u0026#39;: \u0026lt;attribute \u0026#39;__dict__\u0026#39; of \u0026#39;A\u0026#39; objects\u0026gt;, # \u0026#39;__doc__\u0026#39;: None, # \u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, # \u0026#39;__weakref__\u0026#39;: \u0026lt;attribute \u0026#39;__weakref__\u0026#39; of \u0026#39;A\u0026#39; objects\u0026gt;, # \u0026#39;_private_method\u0026#39;: \u0026lt;function __main__.A._private_method\u0026gt;, # \u0026#39;public_method\u0026#39;: \u0026lt;function __main__.A.public_method\u0026gt;}) 3.2.2 函数与绑定方法     类方法本质上是一个函数，通过绑定对象的方式依附在类上成为方法。\n假如有下面一个类：\nclass A:  def __init__(self):  self.val = 1  def f(self):  return self.val 可以看到f是A的属性列表中的一个函数：\nA.f # \u0026lt;function __main__.A.f\u0026gt; A.__dict__[\u0026#39;f\u0026#39;] # \u0026lt;function __main__.A.f\u0026gt; 而当直接用A.f()的方式调用f方法时，会抛出一个异常，异常的原因很直接，参数列表有一个self参数，调用时却没有指定这个参数。而用A().f()的方式调用f方法时同样没有指定参数，却能正常执行，这是为什么呢？\n执行A().f语句可以发现，这时候的f不再是一个函数，而是一个绑定方法，而它绑定的对象则是一个A的实例对象，换句话说，这时候f参数中的self已经跟这个实例对象绑定在一起了，所以用实例调用一个普通方法时，无须人为地去指定第一个参数。\nA.f() # TypeError: f() missing 1 required positional argument: \u0026#39;self\u0026#39; A().f() # auto binding # 1 A().f # \u0026lt;bound method A.f of \u0026lt;__main__.A object at 0x121a3bac8\u0026gt;\u0026gt; 通过调用f函数的__get__（函数的描述器行为）方法来为函数绑定到一个对象上：\nclass B:  def __init__(self):  self.val = \u0026#39;B\u0026#39;  A.f.__get__(B(), B) # \u0026lt;bound method A.f of \u0026lt;__main__.B object at 0x111f9b198\u0026gt;\u0026gt; A.f.__get__(B(), B)() # B 通过types模块的MethodType动态把方法附加到一个实例上：\nimport types def g(self):  return self.val + 1  a.g = types.MethodType(g, a) a.g() # 2 3.2.3 实例方法、类方法、静态方法     类方法分为普通方法，静态方法和类方法，静态方法和类方法可分别通过classmethod和staticmethod装饰器来定义。\n区别于普通方法，类方法的第一个参数绑定的是类对象，因此可以不需要实例对象，直接用类调用类方法执行。\n而静态方法则没有绑定参数，跟类方法一样，可以通过类或者实例直接调用。\nclass C:  def instance_method(self):  print(self)   @classmethod  def class_method(cls):  print(cls)   @staticmethod  def static_method():  pass  C.instance_method # \u0026lt;function __main__.C.instance_method\u0026gt; C.instance_method() # TypeError: instance_method() missing 1 required positional argument: \u0026#39;self\u0026#39; C().instance_method() # \u0026lt;__main__.C object at 0x121133b00\u0026gt; C.class_method # \u0026lt;bound method C.class_method of \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;\u0026gt; C.class_method() # \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt; C().class_method() # \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt; C.static_method # \u0026lt;function __main__.C.static_method\u0026gt; C.static_method() # None C().static_method() # None 通过输出可以看到的一点就是，类方法是一个已经绑定类对象的方法，而普通方法和静态方法在被调用前只是一个普通函数。\n3.2.4 property     property是一个内置函数，它可以将方法与属性调用绑定在一起。\n看下面这个例子，Person类有个年龄属性age，现在想要在对这个属性赋值时给它加一个类型校验，借助于property函数便能在不需要修改用法的情况下为属性加上getter/setter方法：\nclass Person:  def __init__(self, age):  self._age = age   @property  def age(self):  return self._age   @age.setter  def age(self, age):  if not isinstance(age, int):  raise TypeError(\u0026#39;age must be an integer\u0026#39;)  self._age = age   p = Person(20) print(p.age) # 20 p.age = 30 print(p.age) # 30 p.age = \u0026#39;40\u0026#39; # Traceback (most recent call last): # File \u0026#34;test.py\u0026#34;, line 20, in \u0026lt;module\u0026gt; # p.age = \u0026#39;40\u0026#39; # File \u0026#34;test.py\u0026#34;, line 12, in age # raise TypeError(\u0026#39;age must be an integer\u0026#39;) # TypeError: age must be an integer property还常用于延迟计算以及属性缓存，例如下面Circle类的area属性，只有在被访问到的情况下才进行计算，并把结果缓存到实例的属性上。\nclass Circle(object):  def __init__(self, radius):  self.radius = radius   @property  def area(self):  if not hasattr(self, \u0026#39;_cache_area\u0026#39;):  print(\u0026#39;evalute\u0026#39;)  setattr(self, \u0026#39;_cache_area\u0026#39;, 3.14 * self.radius ** 2)  return getattr(self, \u0026#39;_cache_area\u0026#39;)  c = Circle(4) print(c.area) # evalute # 50.24 print(c.area) # 50.24 3.2.5 描述器     上面谈论到的property也好，classmethod和staticmethod也好，甚至是所有的函数，本质上都是实现了描述器协议的对象。\n描述器是一个绑定行为的对象属性，如果一个对象定义了__set__()和__get__()，那么它就是一个数据描述器，如果只定义了__get__()，那么它就是一个非数据描述器。\n下面定义了一个描述器类Integer，这个类的一个实例作为类属性赋给类C的num变量上，当C的实例访问这个属性时便会触发描述器协议，调用描述器的__get__方法，其中第一个参数是实例本身，而第二个参数是实例所归属的类（是否跟实例方法的调用有异曲同工之妙？），如果属性是以类的形式访问，那么第一个参数的值为None；相似地，当对这个属性进行赋值操作时，则会调用描述器的__set__方法，借用这个特性可以方便对属性做一些校验操作。\nclass Integer:  def __init__(self, name):  self.name = name  self.val = None   def __get__(self, obj, obj_type):  print(obj, obj_type)  return self.name   def __set__(self, obj, val):  if not isinstance(val, int):  raise Exception(\u0026#39;value must be an integer!\u0026#39;)  print(\u0026#39;set value to {}\u0026#39;.format(val))  self.val = val   class C:  num = Integer(\u0026#39;i\u0026#39;)   c = C() c.num # \u0026lt;__main__.C object at 0x10cc735c0\u0026gt; \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt; c.num = 5 # set value to 5 c.num = \u0026#39;5\u0026#39; # Exception: value must be an integer! 说到这里已经可以猜到property是如何实现的了，实际上Python官方已经给出了一份模拟property实现的Python代码：\nclass Property(object):  \u0026#34;Emulate PyProperty_Type() in Objects/descrobject.c\u0026#34;   def __init__(self, fget=None, fset=None, fdel=None, doc=None):  self.fget = fget  self.fset = fset  self.fdel = fdel  if doc is None and fget is not None:  doc = fget.__doc__  self.__doc__ = doc   def __get__(self, obj, objtype=None):  if obj is None:  return self  if self.fget is None:  raise AttributeError(\u0026#34;unreadable attribute\u0026#34;)  return self.fget(obj)   def __set__(self, obj, value):  if self.fset is None:  raise AttributeError(\u0026#34;can\u0026#39;t set attribute\u0026#34;)  self.fset(obj, value)   def __delete__(self, obj):  if self.fdel is None:  raise AttributeError(\u0026#34;can\u0026#39;t delete attribute\u0026#34;)  self.fdel(obj)   def getter(self, fget):  return type(self)(fget, self.fset, self.fdel, self.__doc__)   def setter(self, fset):  return type(self)(self.fget, fset, self.fdel, self.__doc__)   def deleter(self, fdel):  return type(self)(self.fget, self.fset, fdel, self.__doc__) classmethod的实现则更为简单一些：\nclass ClassMethod(object):  \u0026#34;Emulate PyClassMethod_Type() in Objects/funcobject.c\u0026#34;   def __init__(self, f):  self.f = f   def __get__(self, obj, klass=None):  if klass is None:  klass = type(obj)  def newfunc(*args):  return self.f(klass, *args)  return newfunc 3.2.6 运算符     Python的每个运算符在背后都对于着特定的方法，重写这些方法可以实现自定义操作符应用在对象时的行为。\n二元运算符\n   操作 方法     + object._add_(self, other)   - object._sub_(self, other)   * object._mul_(self, other)   // object._floordiv_(self, other)   / object._truediv_(self, other)   % object._mod_(self, other)   ** object._pow_(self, other[, modulo])   \u0026laquo; object._lshift_(self, other)   \u0026raquo; object._rshift_(self, other)   \u0026amp; object._and_(self, other)   ^ object._xor_(self, other)   | object._or_(self, other)    扩展赋值运算符\n   操作 方法     += object._iadd_(self, other)   -= object._isub_(self, other)   *= object._imul_(self, other)   /= object._idiv_(self, other)   //= object._ifloordiv_(self, other)   %= object._imod_(self, other)   **= object._ipow_(self, other[, modulo])   \u0026laquo;= object._ilshift_(self, other)   \u0026raquo;= object._irshift_(self, other)   \u0026amp;= object._iand_(self, other)   ^= object._ixor_(self, other)   |= object._ior_(self, other)    一元运算符\n   操作 方法     - object._neg_(self)   + object._pos_(self)   abs() object._abs_(self)   ~ object._invert_(self)   complex() object._complex_(self)   int() object._int_(self)   long() object._long_(self)   float() object._float_(self)   oct() object._oct_(self)   hex() object._hex_(self)    比较运算符\n   操作 方法     \u0026lt; object._lt_(self, other)   \u0026lt;= object._le_(self, other)   == object._eq_(self, other)   != object._ne_(self, other)   \u0026gt;= object._ge_(self, other)   \u0026gt; object._gt_(self, other)    覆盖操作符的行为：\nclass Num:  def __init__(self, val=0):  self.val = val  def __add__(self, other):  return Num(self.val - other)  def __sub__(self, other):  return Num(self.val + other)  def __repr__(self):  return str(self.val)  num = Num(1) result = num + 1 # 0 result = num - 1 # 2 3.2.7 slots     对于定义了__slots__的类，无法随意添加属性到类上，而是只能对__slots__指定的属性进行操作。\n而这也是一种对于存在大量简单对象时，有效降低内存占用的其中一种方式：\nclass MemoryCheck:  def __enter__(self):  tracemalloc.start()  def __exit__(self, exc_type, exc_val, exc_tb):  snapshot = tracemalloc.take_snapshot()  top_stats = snapshot.statistics(\u0026#39;lineno\u0026#39;)  print(\u0026#34;[ Top 1 ]\u0026#34;)  for stat in top_stats[:1]:  print(stat)  with MemoryCheck():  class Object:  def __init__(self, x, y):  self.x = x  self.y = y  objs = []  for i in range(1000000):  objs.append(Object(i, i + 1)) \u0026#39;\u0026#39;\u0026#39; [ Top 1 ] \u0026lt;ipython-input-132-47931446414b\u0026gt;:4: size=107 MiB, count=1999958, average=56 B \u0026#39;\u0026#39;\u0026#39; with MemoryCheck():  class Object:  __slots__ = (\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;)  def __init__(self, x, y):  self.x = x  self.y = y  objs = []  for i in range(1000000):  objs.append(Object(i, i + 1)) \u0026#39;\u0026#39;\u0026#39; [ Top 1 ] \u0026lt;ipython-input-133-cc08066bfb2a\u0026gt;:9: size=88.4 MiB, count=1999747, average=46 B \u0026#39;\u0026#39;\u0026#39; 3.2.8 元类     元类能动态地创建类，而且也能控制类的创建行为。\nimport inspect  class MethodLowerCase(type):  def __new__(mcs, name, bases, attrs):  for name, val in attrs.items():  if callable(val):  if name.lower() != name:  print(\u0026#39;method: {}should be lowercase\u0026#39;.format(name))  else:  print(\u0026#39;method: {}is valid\u0026#39;.format(name))  new_cls = type.__new__(mcs, name, bases, attrs)  return new_cls   class Test(metaclass=MethodLowerCase):  def test_a(self):  pass   def testB(self):  pass  # method: test_a is valid # method: testB should be lowercase 4. 特性     4.1 The Zen of Python     import this 4.2 Pythonic     遍历列表\narray = [1, 2, 3, 4, 5]  for i in range(len(array)):  print (i, array[i])  # Pythonic  for i, item in enumerate(array):  print (i, item) 对列表的操作\narray = [1, 2, 3, 4, 5]  new_array = [] for item in array:  new_array.append(str(item))  # Pythonic new_array = [str(item) for item in array]  # Generator new_array = (str(item) for item in array)  # 函数式 new_array = map(str, array) 列表推导\n# 生成列表 [ i*i for i in range(10) if i % 2 == 0 ] # 生成集合 { i*i for i in range(10) if i % 2 == 0 } # 生成字典 { i:i for i in range(10) if i % 2 == 0 } 上下文管理器\nfile = open(\u0026#39;file\u0026#39;, \u0026#39;w\u0026#39;) file.write(123) file.close()  # Pythonic with open(\u0026#39;file\u0026#39;, \u0026#39;w\u0026#39;) as file:  file.write(123) 条件判断\nif x is True:  y = 1 else:  y = -1  # Pythonic y = 1 if x is True else -1 构造矩阵\ny = [0 for _ in range(100000000)] # Pythonic y = [0] * 100000000 装饰器\ndef logic(x):  if x \u0026lt; 0:  return False  print (x)  return True  #Pythonic def check_gt_zero(func):  def wrapper(x):  if x \u0026lt; 0:  return False  return func(x)  return wrapper  @check_gt_zero def logic(x):  print (x)  return True 变量交换\ntemp = y y = x x = temp  # Pythonic x, y = y, x 切片\narray = [1, 2, 3, 4, 5]  l = len(array) for i in range(l/2):  temp = array[l - i - 1]  array[l - i - 1] = array[i]  array[i] = temp  array = list(reversed(array)) # Pythonic array = array[::-1] 读取文件\nCHUNK_SIZE = 1024  with open(\u0026#39;test.json\u0026#39;) as f:  chunk = f.read(CHUNK_SIZE)  while chunk:  if chunk:  print(chunk)  chunk = f.read(CHUNK_SIZE)  from functools import partial # Pythonic with open(\u0026#39;test.json\u0026#39;) as f:  for piece in iter(partial(f.read, CHUNK_SIZE), \u0026#39;\u0026#39;):  print (piece)  # Lambda with open(\u0026#39;test.json\u0026#39;) as f:  for piece in iter(lambda: f.read(CHUNK_SIZE), \u0026#39;\u0026#39;):  print (piece) for-else和try-else语法\nis_for_finished = True  try:  for item in array:  print (item)  # raise Exception except:  is_for_finished = False  if is_for_finished is True:  print (\u0026#39;complete\u0026#39;)  # Pythonic for item in array:  print (item)  # raise Exception else:  print (\u0026#39;complete\u0026#39;)  try:  print (\u0026#39;try\u0026#39;)  # raise Exception except Exception:  print (\u0026#39;exception\u0026#39;) else:  print (\u0026#39;complete\u0026#39;) 函数参数解压\ndef draw_point(x, y):  # do some magic  point_foo = (3, 4) point_bar = {\u0026#39;y\u0026#39;: 3, \u0026#39;x\u0026#39;: 2}  draw_point(*point_foo) draw_point(**point_bar) 列表/元组解压\nfirst, second, *rest = (1,2,3,4,5,6,7,8) \u0026ldquo;Print To\u0026quot;语法\nprint (\u0026#34;hello world\u0026#34;, file=open(\u0026#34;myfile\u0026#34;, \u0026#34;w\u0026#34;)) 字典缺省值\nd = {}  try:  d[\u0026#39;count\u0026#39;] = d[\u0026#39;count\u0026#39;] + 1 except KeyError:  d[\u0026#39;count\u0026#39;] = 0  # Pythonic d[\u0026#39;count\u0026#39;] = d.get(\u0026#39;count\u0026#39;, 0) + 1 链式比较符\nif x \u0026lt; 100 and x \u0026gt; 0:  print(x)  # Pythonic if 0 \u0026lt; x \u0026lt; 100:  print(x) 多行字符串\ns = (\u0026#34;longlongstringiii\u0026#34;  \u0026#34;iiiiiiiii\u0026#34;  \u0026#34;iiiiiii\u0026#34;) in表达式\nif \u0026#39;string\u0026#39;.find(\u0026#39;ring\u0026#39;) \u0026gt; 0:  print (\u0026#39;find\u0026#39;)  # Pythonic if \u0026#39;ring\u0026#39; in \u0026#39;string\u0026#39;:  print (\u0026#39;find\u0026#39;)  for r in [\u0026#39;ring\u0026#39;, \u0026#39;ring1\u0026#39;, \u0026#39;ring2\u0026#39;]:  if r == \u0026#39;ring\u0026#39;:  print (\u0026#39;find\u0026#39;)  # Pythonic if \u0026#39;ring\u0026#39; in [\u0026#39;ring\u0026#39;, \u0026#39;ring1\u0026#39;, \u0026#39;ring2\u0026#39;]:  print(\u0026#39;find\u0026#39;) 字符串连接\narray = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] s = array[0] for char in array[1:]:  s += \u0026#39;,\u0026#39; + char  # Pythonic s = \u0026#39;,\u0026#39;.join(array) 列表合并字典\nkeys = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] values = [1, 2, 3]  d = {} for key, value in zip(keys, values):  d[key] = value  # Better d = dict(zip(keys, values))  # Pythonic d = {key: value for key, value in zip(keys, values)} all和any\nflag = True for cond in conditions:  if cond is False:  flag = False  break # Pythonic flag = all(conditions)  flag = False for cond in conditions:  if cond is True:  flag = True  break # Pythonic flag = any(conditions) or\nnot_null_string = \u0026#39;\u0026#39; or \u0026#39;string1\u0026#39; or \u0026#39;string2\u0026#39; # string1 方法提取\nfor item in [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]:  array.append(item) # Faster append = array.append for item in [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]:  append(item) 单例模式\nfrom [module] import [single_instance] 用\u0026lt;\u0026gt;代替!=\nIn [1]: from __future__ import barry_as_FLUFL  In [2]: 1 == 1 Out[2]: True  In [3]: 1 != 1  File \u0026#34;\u0026lt;ipython-input-3-1ec724d2c3b1\u0026gt;\u0026#34;, line 1  1 != 1  ^ SyntaxError: invalid syntax   In [4]: 1 \u0026lt;\u0026gt; 1 Out[4]: False 格式化一个json文件\npython -m json.tool test.json echo \u0026#39;{\u0026#34;json\u0026#34;:\u0026#34;obj\u0026#34;}\u0026#39; | python -m json.tool # 管道 开启本地目录的HTTP服务器\npython3 -m http.server 8080 4.3 陷阱     4.3.1 可变的默认参数     def append_to(element, to=[]):  to.append(element)  return to  my_list = append_to(12) print(my_list)  my_other_list = append_to(42) print(my_other_list)  # [12] # [12, 42] 4.3.2 闭包的延迟绑定     def create_multipliers():  return [lambda x : i * x for i in range(5)]  for multiplier in create_multipliers():  print multiplier(2)  # 8 # 8 # 8 # 8 # 8 4.4 小整数缓存     在下面这个例子中， 两个值相等的整形变量在两次比较地址时出现了不一样的情况，原因时因为Python会把频繁使用的小整数放在内存池中，因此在Python中使用范围在[-5,256]的数字时都会得到相同的内存地址。\na = 256 b = 256 id(a) == id(b) # True a = 257 b = 257 id(a) == id(b) # False 4.5 GIL     受制于GIL(Global Interpreter Lock，全局解释锁）的存在，Python进程中的多线程无法利用多核的计算资源，同一时间内只有一个线程可以持有全局解释锁，执行代码指令。\n根据Python虚拟机中的执行机制，每当线程执行若干条虚拟指令后，时间片就会调度给另一个线程。这个间隔时间可以用sys模块的getswitchinterval函数看到：\nsys.getswitchinterval() # 0.005 以上输出表明，每隔0.005秒，这种调度便会发生一次。\n所以可以看到，由于这种机制的存在，下面这两段代码在相同环境下，很可能是带线程的版本执行时间更长：\ndef count(n):  while n \u0026gt; 0:  n -= 1  count(100000000) count(100000000)  t1 = Thread(target=count,args=(100000000,)) t1.start() t2 = Thread(target=count,args=(100000000,)) t2.start() t1.join(); t2.join() 在Python中多线程更适用于IO密集型的任务，比如网络任务，异步请求等，如果需要获得并行的能力，应该使用多进程模块。\n在一个Python进程当中，可以有多个解释器的存在，一个解释器中保存了指向其他解释器的指针，以及一个指向线程状态表的指针，每当创建一个线程，就会往状态表中添加一条记录，线程状态(tstate)对应了真实的线程，还包含了其对应的栈帧信息。\n4.6 池化     在Python的实现里广泛使用了内存池技术来提高性能，一些相同且无特殊意义的对象也常被池化，减少了对象数量以及内存占用。\n举其中一个例子，有A，B，C三个类，其中只有C定义了文档字符串，这时候用A.__doc__ is B.__doc__就能发现，它们使用的内存地址是一样的，说明类的__doc__属性默认都被池化了，而再执行A.__doc__ is C.__doc__就会看到结果是False，说明只有定义了doc-string的时候，__doc__属性才会被分配新的内存。\nclass A: pass  class B: pass  class C:  \u0026#39;\u0026#39;\u0026#39;doc-string\u0026#39;\u0026#39;\u0026#39; \tpass  A is B # False A.__doc__ is B.__doc__ # True A.__doc__ is C.__doc__ # False 对于简单字符串，Python会将其放进内存池中，当字符串的引用变为0时，再把它的内存释放。\na = \u0026#39;HelloWorld\u0026#39; b = \u0026#39;HelloWorld\u0026#39; a is b # True 但再看下面这个例子，在字符串中间插入一个空格后，虽然a和b还是相同的值，但是内存地址却是不一样的：\na = \u0026#39;Hello World\u0026#39; b = \u0026#39;Hello World\u0026#39; a is b # False a = \u0026#39; \u0026#39; b = \u0026#39; \u0026#39; a is b # True 这是因为Python认为的简单字符串一般只包含字母或数字，因此对于这种带有额外字符的字符串，Python是不会将其池化的。\na = \u0026#39;汉字\u0026#39; b = \u0026#39;汉字\u0026#39; a is b # False 在Python 3.x中，可以用sys模块的intern方法来给程序运行期间动态生成的字符串池化。\nimport sys a = \u0026#39;汉字\u0026#39; b = \u0026#39;汉字\u0026#39; a = sys.intern(a) b = sys.intern(b) a is b # True 4.7 跟踪函数     利用sys模块的settrace函数可以注册线程的跟踪函数，跟踪函数应具有三个参数：frame，event 和arg。\n frame：当前的堆栈帧。 event：一个代表跟踪事件字符串，其值为\u0026rsquo;call\u0026rsquo;、 \u0026rsquo;line\u0026rsquo;、 \u0026lsquo;return\u0026rsquo;、 \u0026rsquo;exception\u0026rsquo;、 \u0026lsquo;c_call\u0026rsquo;、 \u0026lsquo;c_return\u0026rsquo;或\u0026rsquo;c_exception\u0026rsquo;。 arg：在event不同的时候有不一样的含义。  在下面这个例子中，给全局设置了一个跟踪函数，当程序发生调用事件（例如一个函数调用了另一个函数）时，Python便会回调跟踪函数，把函数的栈帧，事件类型以及时间类型的参数传入钩子函数中。\nclass TreeStdout:  \u0026#34;\u0026#34;\u0026#34;把标准输出显示出函数调用层级的关系 \u0026#34;\u0026#34;\u0026#34;  def __init__(self, fill_symbol=\u0026#34;\\t\u0026#34;):  self.stack = []  self.old_write = sys.stdout.write  self.symbol = fill_symbol   def _get_stdout_writer(self, depth):  def _writer(data):  if data != \u0026#34;\\n\u0026#34;:  self.old_write(self.symbol * depth + data)  else:  self.old_write(data)  return _writer   def _trace_calls(self, frame, event, arg):  if event == \u0026#39;return\u0026#39;:  self.stack.pop()  if event != \u0026#39;call\u0026#39;:  return  co = frame.f_code  func_name = co.co_name  if func_name == \u0026#39;write\u0026#39;:  return  caller = frame.f_back  if caller is None:  return  caller_name = caller.f_code.co_name  self.stack.append(caller_name)   depth = len(self.stack) - 1  sys.stdout.write = self._get_stdout_writer(depth)  return self._trace_calls   def __enter__(self):  sys.settrace(self._trace_calls)   def __exit__(self, exc_type, exc_val, exc_tb):  self.stack.clear()  sys.stdout.write = self.old_write  sys.settrace(None)  def f():  print(\u0026#39;inside f()\u0026#39;)  def d():  print(\u0026#39;inside d()\u0026#39;)  def e():  print(\u0026#39;inside e()\u0026#39;)  f()  def c():  print(\u0026#39;inside c()\u0026#39;)  d()  e()  e()  def b():  print(\u0026#39;inside b()\u0026#39;)  def a():  print(\u0026#39;inside a()\u0026#39;)  b()  c()  with TreeStdout():  a()  # inside a() # inside b() # inside c() # inside d() # inside e() # inside f() # inside e() # inside f()  欢迎学习讨论和交流，如果觉得本文对你有帮助，欢迎点个star，谢谢。\n"},{"id":8,"href":"/python/python_cheat_sheet/","title":"Python_cheat_sheet","parent":"Pythons","content":"Comprehensive Python Cheatsheet     Download text file, Buy PDF, Fork me on GitHub or Check out FAQ. Contents       1. Collections:   List, Dictionary, Set, Tuple, Range, Enumerate, Iterator, Generator.\n  2. Types:   Type, String, Regular_Exp, Format, Numbers, Combinatorics, Datetime.\n  3. Syntax:   Args, Inline, Closure, Decorator, Class, Duck_Type, Enum, Exception.\n  4. System:   Exit, Print, Input, Command_Line_Arguments, Open, Path, OS_Commands.\n  5. Data:   JSON, Pickle, CSV, SQLite, Bytes, Struct, Array, Memory_View, Deque.\n  6. Advanced:   Threading, Operator, Introspection, Metaprograming, Eval, Coroutines.\n  7. Libraries:   Progress_Bar, Plot, Table, Curses, Logging, Scraping, Web, Profile,\n  NumPy, Image, Audio, Pygame.\nMain     if __name__ == \u0026#39;__main__\u0026#39;: # Runs main() if file wasn\u0026#39;t imported.  main() List     \u0026lt;list\u0026gt; = \u0026lt;list\u0026gt;[from_inclusive : to_exclusive : ±step_size] \u0026lt;list\u0026gt;.append(\u0026lt;el\u0026gt;) # Or: \u0026lt;list\u0026gt; += [\u0026lt;el\u0026gt;] \u0026lt;list\u0026gt;.extend(\u0026lt;collection\u0026gt;) # Or: \u0026lt;list\u0026gt; += \u0026lt;collection\u0026gt; \u0026lt;list\u0026gt;.sort() \u0026lt;list\u0026gt;.reverse() \u0026lt;list\u0026gt; = sorted(\u0026lt;collection\u0026gt;) \u0026lt;iter\u0026gt; = reversed(\u0026lt;list\u0026gt;) sum_of_elements = sum(\u0026lt;collection\u0026gt;) elementwise_sum = [sum(pair) for pair in zip(list_a, list_b)] sorted_by_second = sorted(\u0026lt;collection\u0026gt;, key=lambda el: el[1]) sorted_by_both = sorted(\u0026lt;collection\u0026gt;, key=lambda el: (el[1], el[0])) flatter_list = list(itertools.chain.from_iterable(\u0026lt;list\u0026gt;)) product_of_elems = functools.reduce(lambda out, el: out * el, \u0026lt;collection\u0026gt;) list_of_chars = list(\u0026lt;str\u0026gt;)  Module operator provides functions itemgetter() and mul() that offer the same functionality as lambda expressions above.  \u0026lt;int\u0026gt; = \u0026lt;list\u0026gt;.count(\u0026lt;el\u0026gt;) # Returns number of occurrences. Also works on strings. index = \u0026lt;list\u0026gt;.index(\u0026lt;el\u0026gt;) # Returns index of first occurrence or raises ValueError. \u0026lt;list\u0026gt;.insert(index, \u0026lt;el\u0026gt;) # Inserts item at index and moves the rest to the right. \u0026lt;el\u0026gt; = \u0026lt;list\u0026gt;.pop([index]) # Removes and returns item at index or from the end. \u0026lt;list\u0026gt;.remove(\u0026lt;el\u0026gt;) # Removes first occurrence of item or raises ValueError. \u0026lt;list\u0026gt;.clear() # Removes all items. Also works on dictionary and set. Dictionary     \u0026lt;view\u0026gt; = \u0026lt;dict\u0026gt;.keys() # Coll. of keys that reflects changes. \u0026lt;view\u0026gt; = \u0026lt;dict\u0026gt;.values() # Coll. of values that reflects changes. \u0026lt;view\u0026gt; = \u0026lt;dict\u0026gt;.items() # Coll. of key-value tuples that reflects chgs. value = \u0026lt;dict\u0026gt;.get(key, default=None) # Returns default if key is missing. value = \u0026lt;dict\u0026gt;.setdefault(key, default=None) # Returns and writes default if key is missing. \u0026lt;dict\u0026gt; = collections.defaultdict(\u0026lt;type\u0026gt;) # Creates a dict with default value of type. \u0026lt;dict\u0026gt; = collections.defaultdict(lambda: 1) # Creates a dict with default value 1. \u0026lt;dict\u0026gt; = dict(\u0026lt;collection\u0026gt;) # Creates a dict from coll. of key-value pairs. \u0026lt;dict\u0026gt; = dict(zip(keys, values)) # Creates a dict from two collections. \u0026lt;dict\u0026gt; = dict.fromkeys(keys [, value]) # Creates a dict from collection of keys. \u0026lt;dict\u0026gt;.update(\u0026lt;dict\u0026gt;) # Adds items. Replaces ones with matching keys. value = \u0026lt;dict\u0026gt;.pop(key) # Removes item or raises KeyError. {k for k, v in \u0026lt;dict\u0026gt;.items() if v == value} # Returns set of keys that point to the value. {k: v for k, v in \u0026lt;dict\u0026gt;.items() if k in keys} # Returns a dictionary, filtered by keys. Counter     \u0026gt;\u0026gt;\u0026gt; from collections import Counter \u0026gt;\u0026gt;\u0026gt; colors = [\u0026#39;blue\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;red\u0026#39;] \u0026gt;\u0026gt;\u0026gt; counter = Counter(colors) \u0026gt;\u0026gt;\u0026gt; counter[\u0026#39;yellow\u0026#39;] += 1 Counter({\u0026#39;blue\u0026#39;: 3, \u0026#39;red\u0026#39;: 2, \u0026#39;yellow\u0026#39;: 1}) \u0026gt;\u0026gt;\u0026gt; counter.most_common()[0] (\u0026#39;blue\u0026#39;, 3) Set     \u0026lt;set\u0026gt; = set() \u0026lt;set\u0026gt;.add(\u0026lt;el\u0026gt;) # Or: \u0026lt;set\u0026gt; |= {\u0026lt;el\u0026gt;} \u0026lt;set\u0026gt;.update(\u0026lt;collection\u0026gt;) # Or: \u0026lt;set\u0026gt; |= \u0026lt;set\u0026gt; \u0026lt;set\u0026gt; = \u0026lt;set\u0026gt;.union(\u0026lt;coll.\u0026gt;) # Or: \u0026lt;set\u0026gt; | \u0026lt;set\u0026gt; \u0026lt;set\u0026gt; = \u0026lt;set\u0026gt;.intersection(\u0026lt;coll.\u0026gt;) # Or: \u0026lt;set\u0026gt; \u0026amp; \u0026lt;set\u0026gt; \u0026lt;set\u0026gt; = \u0026lt;set\u0026gt;.difference(\u0026lt;coll.\u0026gt;) # Or: \u0026lt;set\u0026gt; - \u0026lt;set\u0026gt; \u0026lt;set\u0026gt; = \u0026lt;set\u0026gt;.symmetric_difference(\u0026lt;coll.\u0026gt;) # Or: \u0026lt;set\u0026gt; ^ \u0026lt;set\u0026gt; \u0026lt;bool\u0026gt; = \u0026lt;set\u0026gt;.issubset(\u0026lt;coll.\u0026gt;) # Or: \u0026lt;set\u0026gt; \u0026lt;= \u0026lt;set\u0026gt; \u0026lt;bool\u0026gt; = \u0026lt;set\u0026gt;.issuperset(\u0026lt;coll.\u0026gt;) # Or: \u0026lt;set\u0026gt; \u0026gt;= \u0026lt;set\u0026gt; \u0026lt;el\u0026gt; = \u0026lt;set\u0026gt;.pop() # Raises KeyError if empty. \u0026lt;set\u0026gt;.remove(\u0026lt;el\u0026gt;) # Raises KeyError if missing. \u0026lt;set\u0026gt;.discard(\u0026lt;el\u0026gt;) # Doesn\u0026#39;t raise an error. Frozen Set      Is immutable and hashable. That means it can be used as a key in a dictionary or as an element in a set.  \u0026lt;frozenset\u0026gt; = frozenset(\u0026lt;collection\u0026gt;) Tuple     Tuple is an immutable and hashable list.\n\u0026lt;tuple\u0026gt; = () \u0026lt;tuple\u0026gt; = (\u0026lt;el\u0026gt;, ) \u0026lt;tuple\u0026gt; = (\u0026lt;el_1\u0026gt;, \u0026lt;el_2\u0026gt; [, ...]) Named Tuple     Tuple\u0026rsquo;s subclass with named elements.\n\u0026gt;\u0026gt;\u0026gt; from collections import namedtuple \u0026gt;\u0026gt;\u0026gt; Point = namedtuple(\u0026#39;Point\u0026#39;, \u0026#39;x y\u0026#39;) \u0026gt;\u0026gt;\u0026gt; p = Point(1, y=2) Point(x=1, y=2) \u0026gt;\u0026gt;\u0026gt; p[0] 1 \u0026gt;\u0026gt;\u0026gt; p.x 1 \u0026gt;\u0026gt;\u0026gt; getattr(p, \u0026#39;y\u0026#39;) 2 \u0026gt;\u0026gt;\u0026gt; p._fields # Or: Point._fields (\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;) Range     \u0026lt;range\u0026gt; = range(to_exclusive) \u0026lt;range\u0026gt; = range(from_inclusive, to_exclusive) \u0026lt;range\u0026gt; = range(from_inclusive, to_exclusive, ±step_size) from_inclusive = \u0026lt;range\u0026gt;.start to_exclusive = \u0026lt;range\u0026gt;.stop Enumerate     for i, el in enumerate(\u0026lt;collection\u0026gt; [, i_start]):  ... Iterator     \u0026lt;iter\u0026gt; = iter(\u0026lt;collection\u0026gt;) # `iter(\u0026lt;iter\u0026gt;)` returns unmodified iterator. \u0026lt;iter\u0026gt; = iter(\u0026lt;function\u0026gt;, to_exclusive) # A sequence of return values until \u0026#39;to_exclusive\u0026#39;. \u0026lt;el\u0026gt; = next(\u0026lt;iter\u0026gt; [, default]) # Raises StopIteration or returns \u0026#39;default\u0026#39; on end. \u0026lt;list\u0026gt; = list(\u0026lt;iter\u0026gt;) # Returns a list of iterator\u0026#39;s remaining elements. Itertools     from itertools import count, repeat, cycle, chain, islice \u0026lt;iter\u0026gt; = count(start=0, step=1) # Returns updated value endlessly. Accepts floats. \u0026lt;iter\u0026gt; = repeat(\u0026lt;el\u0026gt; [, times]) # Returns element endlessly or \u0026#39;times\u0026#39; times. \u0026lt;iter\u0026gt; = cycle(\u0026lt;collection\u0026gt;) # Repeats the sequence endlessly. \u0026lt;iter\u0026gt; = chain(\u0026lt;coll_1\u0026gt;, \u0026lt;coll_2\u0026gt; [, ...]) # Empties collections in order. \u0026lt;iter\u0026gt; = chain.from_iterable(\u0026lt;collection\u0026gt;) # Empties collections inside a collection in order. \u0026lt;iter\u0026gt; = islice(\u0026lt;collection\u0026gt;, to_exclusive) \u0026lt;iter\u0026gt; = islice(\u0026lt;collection\u0026gt;, from_inclusive, to_exclusive [, +step_size]) Generator      Any function that contains a yield statement returns a generator. Generators and iterators are interchangeable.  def count(start, step):  while True:  yield start  start += step \u0026gt;\u0026gt;\u0026gt; counter = count(10, 2) \u0026gt;\u0026gt;\u0026gt; next(counter), next(counter), next(counter) (10, 12, 14) Type      Everything is an object. Every object has a type. Type and class are synonymous.  \u0026lt;type\u0026gt; = type(\u0026lt;el\u0026gt;) # Or: \u0026lt;el\u0026gt;.__class__ \u0026lt;bool\u0026gt; = isinstance(\u0026lt;el\u0026gt;, \u0026lt;type\u0026gt;) # Or: issubclass(type(\u0026lt;el\u0026gt;), \u0026lt;type\u0026gt;) \u0026gt;\u0026gt;\u0026gt; type(\u0026#39;a\u0026#39;), \u0026#39;a\u0026#39;.__class__, str (\u0026lt;class \u0026#39;str\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;str\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;str\u0026#39;\u0026gt;) Some types do not have built-in names, so they must be imported:     from types import FunctionType, MethodType, LambdaType, GeneratorType Abstract Base Classes     Each abstract base class specifies a set of virtual subclasses. These classes are then recognized by isinstance() and issubclass() as subclasses of the ABC, although they are really not.\n\u0026gt;\u0026gt;\u0026gt; from collections.abc import Sequence, Collection, Iterable \u0026gt;\u0026gt;\u0026gt; isinstance([1, 2, 3], Iterable) True +------------------+------------+------------+------------+ | | Sequence | Collection | Iterable | +------------------+------------+------------+------------+ | list, range, str | yes | yes | yes | | dict, set | | yes | yes | | iter | | | yes | +------------------+------------+------------+------------+ \u0026gt;\u0026gt;\u0026gt; from numbers import Integral, Rational, Real, Complex, Number \u0026gt;\u0026gt;\u0026gt; isinstance(123, Number) True +--------------------+----------+----------+----------+----------+----------+ | | Integral | Rational | Real | Complex | Number | +--------------------+----------+----------+----------+----------+----------+ | int | yes | yes | yes | yes | yes | | fractions.Fraction | | yes | yes | yes | yes | | float | | | yes | yes | yes | | complex | | | | yes | yes | | decimal.Decimal | | | | | yes | +--------------------+----------+----------+----------+----------+----------+ String     \u0026lt;str\u0026gt; = \u0026lt;str\u0026gt;.strip() # Strips all whitespace characters from both ends. \u0026lt;str\u0026gt; = \u0026lt;str\u0026gt;.strip(\u0026#39;\u0026lt;chars\u0026gt;\u0026#39;) # Strips all passed characters from both ends. \u0026lt;list\u0026gt; = \u0026lt;str\u0026gt;.split() # Splits on one or more whitespace characters. \u0026lt;list\u0026gt; = \u0026lt;str\u0026gt;.split(sep=None, maxsplit=-1) # Splits on \u0026#39;sep\u0026#39; str at most \u0026#39;maxsplit\u0026#39; times. \u0026lt;list\u0026gt; = \u0026lt;str\u0026gt;.splitlines(keepends=False) # Splits on \\n,\\r,\\r\\n. Keeps them if \u0026#39;keepends\u0026#39;. \u0026lt;str\u0026gt; = \u0026lt;str\u0026gt;.join(\u0026lt;coll_of_strings\u0026gt;) # Joins elements using string as separator. \u0026lt;bool\u0026gt; = \u0026lt;sub_str\u0026gt; in \u0026lt;str\u0026gt; # Checks if string contains a substring. \u0026lt;bool\u0026gt; = \u0026lt;str\u0026gt;.startswith(\u0026lt;sub_str\u0026gt;) # Pass tuple of strings for multiple options. \u0026lt;bool\u0026gt; = \u0026lt;str\u0026gt;.endswith(\u0026lt;sub_str\u0026gt;) # Pass tuple of strings for multiple options. \u0026lt;int\u0026gt; = \u0026lt;str\u0026gt;.find(\u0026lt;sub_str\u0026gt;) # Returns start index of first match or -1. \u0026lt;int\u0026gt; = \u0026lt;str\u0026gt;.index(\u0026lt;sub_str\u0026gt;) # Same but raises ValueError if missing. \u0026lt;str\u0026gt; = \u0026lt;str\u0026gt;.replace(old, new [, count]) # Replaces \u0026#39;old\u0026#39; with \u0026#39;new\u0026#39; at most \u0026#39;count\u0026#39; times. \u0026lt;str\u0026gt; = \u0026lt;str\u0026gt;.translate(\u0026lt;table\u0026gt;) # Use `str.maketrans(\u0026lt;dict\u0026gt;)` to generate table. \u0026lt;str\u0026gt; = chr(\u0026lt;int\u0026gt;) # Converts int to Unicode char. \u0026lt;int\u0026gt; = ord(\u0026lt;str\u0026gt;) # Converts Unicode char to int.  Also: 'lstrip()', 'rstrip()'. Also: 'lower()', 'upper()', 'capitalize()' and 'title()'.  Property Methods     +---------------+----------+----------+----------+----------+----------+ | | [ !#$%…] | [a-zA-Z] | [¼½¾] | [²³¹] | [0-9] | +---------------+----------+----------+----------+----------+----------+ | isprintable() | yes | yes | yes | yes | yes | | isalnum() | | yes | yes | yes | yes | | isnumeric() | | | yes | yes | yes | | isdigit() | | | | yes | yes | | isdecimal() | | | | | yes | +---------------+----------+----------+----------+----------+----------+  Also: 'isspace()' checks for '[ \\t\\n\\r\\f\\v…]'.  Regex     import re \u0026lt;str\u0026gt; = re.sub(\u0026lt;regex\u0026gt;, new, text, count=0) # Substitutes all occurrences with \u0026#39;new\u0026#39;. \u0026lt;list\u0026gt; = re.findall(\u0026lt;regex\u0026gt;, text) # Returns all occurrences as strings. \u0026lt;list\u0026gt; = re.split(\u0026lt;regex\u0026gt;, text, maxsplit=0) # Use brackets in regex to include the matches. \u0026lt;Match\u0026gt; = re.search(\u0026lt;regex\u0026gt;, text) # Searches for first occurrence of the pattern. \u0026lt;Match\u0026gt; = re.match(\u0026lt;regex\u0026gt;, text) # Searches only at the beginning of the text. \u0026lt;iter\u0026gt; = re.finditer(\u0026lt;regex\u0026gt;, text) # Returns all occurrences as match objects.  Search() and match() return None if they can\u0026rsquo;t find a match. Argument 'flags=re.IGNORECASE' can be used with all functions. Argument 'flags=re.MULTILINE' makes '^' and '$' match the start/end of each line. Argument 'flags=re.DOTALL' makes dot also accept the '\\n'. Use r'\\1' or '\\\\1' for backreference. Add '?' after an operator to make it non-greedy.  Match Object     \u0026lt;str\u0026gt; = \u0026lt;Match\u0026gt;.group() # Returns the whole match. Also group(0). \u0026lt;str\u0026gt; = \u0026lt;Match\u0026gt;.group(1) # Returns part in the first bracket. \u0026lt;tuple\u0026gt; = \u0026lt;Match\u0026gt;.groups() # Returns all bracketed parts. \u0026lt;int\u0026gt; = \u0026lt;Match\u0026gt;.start() # Returns start index of the match. \u0026lt;int\u0026gt; = \u0026lt;Match\u0026gt;.end() # Returns exclusive end index of the match. Special Sequences      By default digits, alphanumerics and whitespaces from all alphabets are matched, unless 'flags=re.ASCII' argument is used. Use a capital letter for negation.  \u0026#39;\\d\u0026#39; == \u0026#39;[0-9]\u0026#39; # Matches any digit. \u0026#39;\\w\u0026#39; == \u0026#39;[a-zA-Z0-9_]\u0026#39; # Matches any alphanumeric. \u0026#39;\\s\u0026#39; == \u0026#39;[ \\t\\n\\r\\f\\v]\u0026#39; # Matches any whitespace. Format     \u0026lt;str\u0026gt; = f\u0026#39;{\u0026lt;el_1\u0026gt;}, {\u0026lt;el_2\u0026gt;}\u0026#39; \u0026lt;str\u0026gt; = \u0026#39;{}, {}\u0026#39;.format(\u0026lt;el_1\u0026gt;, \u0026lt;el_2\u0026gt;) Attributes     \u0026gt;\u0026gt;\u0026gt; from collections import namedtuple \u0026gt;\u0026gt;\u0026gt; Person = namedtuple(\u0026#39;Person\u0026#39;, \u0026#39;name height\u0026#39;) \u0026gt;\u0026gt;\u0026gt; person = Person(\u0026#39;Jean-Luc\u0026#39;, 187) \u0026gt;\u0026gt;\u0026gt; f\u0026#39;{person.height}\u0026#39; \u0026#39;187\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;{p.height}\u0026#39;.format(p=person) \u0026#39;187\u0026#39; General Options     {\u0026lt;el\u0026gt;:\u0026lt;10} # \u0026#39;\u0026lt;el\u0026gt; \u0026#39; {\u0026lt;el\u0026gt;:^10} # \u0026#39; \u0026lt;el\u0026gt; \u0026#39; {\u0026lt;el\u0026gt;:\u0026gt;10} # \u0026#39; \u0026lt;el\u0026gt;\u0026#39; {\u0026lt;el\u0026gt;:.\u0026lt;10} # \u0026#39;\u0026lt;el\u0026gt;......\u0026#39; {\u0026lt;el\u0026gt;:\u0026lt;0} # \u0026#39;\u0026lt;el\u0026gt;\u0026#39; Strings     '!r' calls object\u0026rsquo;s repr() method, instead of str(), to get a string.\n{\u0026#39;abcde\u0026#39;!r:10} # \u0026#34;\u0026#39;abcde\u0026#39; \u0026#34; {\u0026#39;abcde\u0026#39;:10.3} # \u0026#39;abc \u0026#39; {\u0026#39;abcde\u0026#39;:.3} # \u0026#39;abc\u0026#39; Numbers     { 123456:10,} # \u0026#39; 123,456\u0026#39; { 123456:10_} # \u0026#39; 123_456\u0026#39; { 123456:+10} # \u0026#39; +123456\u0026#39; {-123456:=10} # \u0026#39;- 123456\u0026#39; { 123456: } # \u0026#39; 123456\u0026#39; {-123456: } # \u0026#39;-123456\u0026#39; Floats     {1.23456:10.3} # \u0026#39; 1.23\u0026#39; {1.23456:10.3f} # \u0026#39; 1.235\u0026#39; {1.23456:10.3e} # \u0026#39; 1.235e+00\u0026#39; {1.23456:10.3%} # \u0026#39; 123.456%\u0026#39; Comparison of presentation types:     +---------------+-----------------+-----------------+-----------------+-----------------+ | | {\u0026lt;float\u0026gt;} | {\u0026lt;float\u0026gt;:f} | {\u0026lt;float\u0026gt;:e} | {\u0026lt;float\u0026gt;:%} | +---------------+-----------------+-----------------+-----------------+-----------------+ | 0.000056789 | \u0026#39;5.6789e-05\u0026#39; | \u0026#39;0.000057\u0026#39; | \u0026#39;5.678900e-05\u0026#39; | \u0026#39;0.005679%\u0026#39; | | 0.00056789 | \u0026#39;0.00056789\u0026#39; | \u0026#39;0.000568\u0026#39; | \u0026#39;5.678900e-04\u0026#39; | \u0026#39;0.056789%\u0026#39; | | 0.0056789 | \u0026#39;0.0056789\u0026#39; | \u0026#39;0.005679\u0026#39; | \u0026#39;5.678900e-03\u0026#39; | \u0026#39;0.567890%\u0026#39; | | 0.056789 | \u0026#39;0.056789\u0026#39; | \u0026#39;0.056789\u0026#39; | \u0026#39;5.678900e-02\u0026#39; | \u0026#39;5.678900%\u0026#39; | | 0.56789 | \u0026#39;0.56789\u0026#39; | \u0026#39;0.567890\u0026#39; | \u0026#39;5.678900e-01\u0026#39; | \u0026#39;56.789000%\u0026#39; | | 5.6789 | \u0026#39;5.6789\u0026#39; | \u0026#39;5.678900\u0026#39; | \u0026#39;5.678900e+00\u0026#39; | \u0026#39;567.890000%\u0026#39; | | 56.789 | \u0026#39;56.789\u0026#39; | \u0026#39;56.789000\u0026#39; | \u0026#39;5.678900e+01\u0026#39; | \u0026#39;5678.900000%\u0026#39; | | 567.89 | \u0026#39;567.89\u0026#39; | \u0026#39;567.890000\u0026#39; | \u0026#39;5.678900e+02\u0026#39; | \u0026#39;56789.000000%\u0026#39; | +---------------+-----------------+-----------------+-----------------+-----------------+ +---------------+-----------------+-----------------+-----------------+-----------------+ | | {\u0026lt;float\u0026gt;:.2} | {\u0026lt;float\u0026gt;:.2f} | {\u0026lt;float\u0026gt;:.2e} | {\u0026lt;float\u0026gt;:.2%} | +---------------+-----------------+-----------------+-----------------+-----------------+ | 0.000056789 | \u0026#39;5.7e-05\u0026#39; | \u0026#39;0.00\u0026#39; | \u0026#39;5.68e-05\u0026#39; | \u0026#39;0.01%\u0026#39; | | 0.00056789 | \u0026#39;0.00057\u0026#39; | \u0026#39;0.00\u0026#39; | \u0026#39;5.68e-04\u0026#39; | \u0026#39;0.06%\u0026#39; | | 0.0056789 | \u0026#39;0.0057\u0026#39; | \u0026#39;0.01\u0026#39; | \u0026#39;5.68e-03\u0026#39; | \u0026#39;0.57%\u0026#39; | | 0.056789 | \u0026#39;0.057\u0026#39; | \u0026#39;0.06\u0026#39; | \u0026#39;5.68e-02\u0026#39; | \u0026#39;5.68%\u0026#39; | | 0.56789 | \u0026#39;0.57\u0026#39; | \u0026#39;0.57\u0026#39; | \u0026#39;5.68e-01\u0026#39; | \u0026#39;56.79%\u0026#39; | | 5.6789 | \u0026#39;5.7\u0026#39; | \u0026#39;5.68\u0026#39; | \u0026#39;5.68e+00\u0026#39; | \u0026#39;567.89%\u0026#39; | | 56.789 | \u0026#39;5.7e+01\u0026#39; | \u0026#39;56.79\u0026#39; | \u0026#39;5.68e+01\u0026#39; | \u0026#39;5678.90%\u0026#39; | | 567.89 | \u0026#39;5.7e+02\u0026#39; | \u0026#39;567.89\u0026#39; | \u0026#39;5.68e+02\u0026#39; | \u0026#39;56789.00%\u0026#39; | +---------------+-----------------+-----------------+-----------------+-----------------+ Ints     {90:c} # \u0026#39;Z\u0026#39; {90:b} # \u0026#39;1011010\u0026#39; {90:X} # \u0026#39;5A\u0026#39; Numbers     Types     \u0026lt;int\u0026gt; = int(\u0026lt;float/str/bool\u0026gt;) # Or: math.floor(\u0026lt;float\u0026gt;) \u0026lt;float\u0026gt; = float(\u0026lt;int/str/bool\u0026gt;) # Or: \u0026lt;real\u0026gt;e±\u0026lt;int\u0026gt; \u0026lt;complex\u0026gt; = complex(real=0, imag=0) # Or: \u0026lt;real\u0026gt; ± \u0026lt;real\u0026gt;j \u0026lt;Fraction\u0026gt; = fractions.Fraction(numerator=0, denominator=1) \u0026lt;Decimal\u0026gt; = decimal.Decimal(\u0026lt;str/int/float\u0026gt;)  'int(\u0026lt;str\u0026gt;)' and 'float(\u0026lt;str\u0026gt;)' raise ValueError on malformed strings. Decimal numbers can be represented exactly, unlike floats where '1.1 + 2.2 != 3.3'. Precision of decimal operations is set with: 'decimal.getcontext().prec = \u0026lt;int\u0026gt;'.  Basic Functions     \u0026lt;num\u0026gt; = pow(\u0026lt;num\u0026gt;, \u0026lt;num\u0026gt;) # Or: \u0026lt;num\u0026gt; ** \u0026lt;num\u0026gt; \u0026lt;num\u0026gt; = abs(\u0026lt;num\u0026gt;) # \u0026lt;float\u0026gt; = abs(\u0026lt;complex\u0026gt;) \u0026lt;num\u0026gt; = round(\u0026lt;num\u0026gt; [, ±ndigits]) # `round(126, -1) == 130` Math     from math import e, pi, inf, nan, isinf, isnan from math import cos, acos, sin, asin, tan, atan, degrees, radians from math import log, log10, log2 Statistics     from statistics import mean, median, variance, pvariance, pstdev Random     from random import random, randint, choice, shuffle \u0026lt;float\u0026gt; = random() \u0026lt;int\u0026gt; = randint(from_inclusive, to_inclusive) \u0026lt;el\u0026gt; = choice(\u0026lt;list\u0026gt;) shuffle(\u0026lt;list\u0026gt;) Bin, Hex     \u0026lt;int\u0026gt; = 0b\u0026lt;bin\u0026gt; # Or: 0x\u0026lt;hex\u0026gt; \u0026lt;int\u0026gt; = int(\u0026#39;\u0026lt;bin\u0026gt;\u0026#39;, 2) # Or: int(\u0026#39;\u0026lt;hex\u0026gt;\u0026#39;, 16) \u0026lt;int\u0026gt; = int(\u0026#39;0b\u0026lt;bin\u0026gt;\u0026#39;, 0) # Or: int(\u0026#39;0x\u0026lt;hex\u0026gt;\u0026#39;, 0) \u0026#39;0b\u0026lt;bin\u0026gt;\u0026#39; = bin(\u0026lt;int\u0026gt;) # Or: hex(\u0026lt;int\u0026gt;) Bitwise Operators     \u0026lt;int\u0026gt; = \u0026lt;int\u0026gt; \u0026amp; \u0026lt;int\u0026gt; # And \u0026lt;int\u0026gt; = \u0026lt;int\u0026gt; | \u0026lt;int\u0026gt; # Or \u0026lt;int\u0026gt; = \u0026lt;int\u0026gt; ^ \u0026lt;int\u0026gt; # Xor (0 if both bits equal) \u0026lt;int\u0026gt; = \u0026lt;int\u0026gt; \u0026lt;\u0026lt; n_bits # Shift left \u0026lt;int\u0026gt; = \u0026lt;int\u0026gt; \u0026gt;\u0026gt; n_bits # Shift right \u0026lt;int\u0026gt; = ~\u0026lt;int\u0026gt; # Compliment (flips bits) Combinatorics      Every function returns an iterator. If you want to print the iterator, you need to pass it to the list() function first!  from itertools import product, combinations, combinations_with_replacement, permutations \u0026gt;\u0026gt;\u0026gt; product([0, 1], repeat=3) [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1),  (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)] \u0026gt;\u0026gt;\u0026gt; product(\u0026#39;ab\u0026#39;, \u0026#39;12\u0026#39;) [(\u0026#39;a\u0026#39;, \u0026#39;1\u0026#39;), (\u0026#39;a\u0026#39;, \u0026#39;2\u0026#39;),  (\u0026#39;b\u0026#39;, \u0026#39;1\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;2\u0026#39;)] \u0026gt;\u0026gt;\u0026gt; combinations(\u0026#39;abc\u0026#39;, 2) [(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;), (\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;)] \u0026gt;\u0026gt;\u0026gt; combinations_with_replacement(\u0026#39;abc\u0026#39;, 2) [(\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;), (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;), (\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;),  (\u0026#39;b\u0026#39;, \u0026#39;b\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;),  (\u0026#39;c\u0026#39;, \u0026#39;c\u0026#39;)] \u0026gt;\u0026gt;\u0026gt; permutations(\u0026#39;abc\u0026#39;, 2) [(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;), (\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;),  (\u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;),  (\u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;), (\u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;)] Datetime      Module \u0026lsquo;datetime\u0026rsquo; provides \u0026lsquo;date\u0026rsquo; \u0026lt;D\u0026gt;, \u0026rsquo;time\u0026rsquo; \u0026lt;T\u0026gt;, \u0026lsquo;datetime\u0026rsquo; \u0026lt;DT\u0026gt; and \u0026rsquo;timedelta\u0026rsquo; \u0026lt;TD\u0026gt; classes. All are immutable and hashable. Time and datetime objects can be \u0026lsquo;aware\u0026rsquo; \u0026lt;a\u0026gt;, meaning they have defined timezone, or \u0026rsquo;naive\u0026rsquo; \u0026lt;n\u0026gt;, meaning they don\u0026rsquo;t. If object is naive, it is presumed to be in the system\u0026rsquo;s timezone.  from datetime import date, time, datetime, timedelta from dateutil.tz import UTC, tzlocal, gettz, resolve_imaginary Constructors     \u0026lt;D\u0026gt; = date(year, month, day) \u0026lt;T\u0026gt; = time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0) \u0026lt;DT\u0026gt; = datetime(year, month, day, hour=0, minute=0, second=0, ...) \u0026lt;TD\u0026gt; = timedelta(days=0, seconds=0, microseconds=0, milliseconds=0,  minutes=0, hours=0, weeks=0)  Use '\u0026lt;D/DT\u0026gt;.weekday()' to get the day of the week (Mon == 0). 'fold=1' means the second pass in case of time jumping back for one hour. '\u0026lt;DTa\u0026gt; = resolve_imaginary(\u0026lt;DTa\u0026gt;)' fixes DTs that fall into the missing hour.  Now     \u0026lt;D/DTn\u0026gt; = D/DT.today() # Current local date or naive datetime. \u0026lt;DTn\u0026gt; = DT.utcnow() # Naive datetime from current UTC time. \u0026lt;DTa\u0026gt; = DT.now(\u0026lt;tzinfo\u0026gt;) # Aware datetime from current tz time.  To extract time use '\u0026lt;DTn\u0026gt;.time()', '\u0026lt;DTa\u0026gt;.time()' or '\u0026lt;DTa\u0026gt;.timetz()'.  Timezone     \u0026lt;tzinfo\u0026gt; = UTC # UTC timezone. London without DST. \u0026lt;tzinfo\u0026gt; = tzlocal() # Local timezone. Also gettz(). \u0026lt;tzinfo\u0026gt; = gettz(\u0026#39;\u0026lt;Continent\u0026gt;/\u0026lt;City\u0026gt;\u0026#39;) # \u0026#39;Continent/City_Name\u0026#39; timezone or None. \u0026lt;DTa\u0026gt; = \u0026lt;DT\u0026gt;.astimezone(\u0026lt;tzinfo\u0026gt;) # Datetime, converted to passed timezone. \u0026lt;Ta/DTa\u0026gt; = \u0026lt;T/DT\u0026gt;.replace(tzinfo=\u0026lt;tzinfo\u0026gt;) # Unconverted object with new timezone. Encode     \u0026lt;D/T/DT\u0026gt; = D/T/DT.fromisoformat(\u0026#39;\u0026lt;iso\u0026gt;\u0026#39;) # Object from ISO string. Raises ValueError. \u0026lt;DT\u0026gt; = DT.strptime(\u0026lt;str\u0026gt;, \u0026#39;\u0026lt;format\u0026gt;\u0026#39;) # Datetime from str, according to format. \u0026lt;D/DTn\u0026gt; = D/DT.fromordinal(\u0026lt;int\u0026gt;) # D/DTn from days since Christ, at midnight. \u0026lt;DTn\u0026gt; = DT.fromtimestamp(\u0026lt;real\u0026gt;) # Local time DTn from seconds since Epoch. \u0026lt;DTa\u0026gt; = DT.fromtimestamp(\u0026lt;real\u0026gt;, \u0026lt;tz.\u0026gt;) # Aware datetime from seconds since Epoch.  ISO strings come in following forms: 'YYYY-MM-DD', 'HH:MM:SS.ffffff[±\u0026lt;offset\u0026gt;]', or both separated by an arbitrary character. Offset is formatted as: 'HH:MM'. Epoch on Unix systems is: '1970-01-01 00:00 UTC', '1970-01-01 01:00 CET', \u0026hellip;  Decode     \u0026lt;str\u0026gt; = \u0026lt;D/T/DT\u0026gt;.isoformat(sep=\u0026#39;T\u0026#39;) # Also timespec=\u0026#39;auto/hours/minutes/seconds\u0026#39;. \u0026lt;str\u0026gt; = \u0026lt;D/T/DT\u0026gt;.strftime(\u0026#39;\u0026lt;format\u0026gt;\u0026#39;) # Custom string representation. \u0026lt;int\u0026gt; = \u0026lt;D/DT\u0026gt;.toordinal() # Days since Christ, ignoring time and tz. \u0026lt;float\u0026gt; = \u0026lt;DTn\u0026gt;.timestamp() # Seconds since Epoch, from DTn in local tz. \u0026lt;float\u0026gt; = \u0026lt;DTa\u0026gt;.timestamp() # Seconds since Epoch, from DTa. Format     \u0026gt;\u0026gt;\u0026gt; from datetime import datetime \u0026gt;\u0026gt;\u0026gt; dt = datetime.strptime(\u0026#39;2015-05-14 23:39:00.00 +0200\u0026#39;, \u0026#39;%Y-%m-%d%H:%M:%S.%f%z\u0026#39;) \u0026gt;\u0026gt;\u0026gt; dt.strftime(\u0026#34;%A, %dth of %B \u0026#39;%y, %I:%M%p %Z\u0026#34;) \u0026#34;Thursday, 14th of May \u0026#39;15, 11:39PM UTC+02:00\u0026#34;  When parsing, '%z' also accepts '±HH:MM'. For abbreviated weekday and month use '%a' and '%b'.  Arithmetics     \u0026lt;D/DT\u0026gt; = \u0026lt;D/DT\u0026gt; ± \u0026lt;TD\u0026gt; # Returned datetime can fall into missing hour. \u0026lt;TD\u0026gt; = \u0026lt;D/DTn\u0026gt; - \u0026lt;D/DTn\u0026gt; # Returns the difference, ignoring time jumps. \u0026lt;TD\u0026gt; = \u0026lt;DTa\u0026gt; - \u0026lt;DTa\u0026gt; # Ignores time jumps if they share tzinfo object. \u0026lt;TD\u0026gt; = \u0026lt;DT_UTC\u0026gt; - \u0026lt;DT_UTC\u0026gt; # Convert DTs to UTC to get the actual delta. Arguments     Inside Function Call     \u0026lt;function\u0026gt;(\u0026lt;positional_args\u0026gt;) # f(0, 0) \u0026lt;function\u0026gt;(\u0026lt;keyword_args\u0026gt;) # f(x=0, y=0) \u0026lt;function\u0026gt;(\u0026lt;positional_args\u0026gt;, \u0026lt;keyword_args\u0026gt;) # f(0, y=0) Inside Function Definition     def f(\u0026lt;nondefault_args\u0026gt;): # def f(x, y): def f(\u0026lt;default_args\u0026gt;): # def f(x=0, y=0): def f(\u0026lt;nondefault_args\u0026gt;, \u0026lt;default_args\u0026gt;): # def f(x, y=0): Splat Operator     Inside Function Call     Splat expands a collection into positional arguments, while splatty-splat expands a dictionary into keyword arguments.\nargs = (1, 2) kwargs = {\u0026#39;x\u0026#39;: 3, \u0026#39;y\u0026#39;: 4, \u0026#39;z\u0026#39;: 5} func(*args, **kwargs) Is the same as:     func(1, 2, x=3, y=4, z=5) Inside Function Definition     Splat combines zero or more positional arguments into a tuple, while splatty-splat combines zero or more keyword arguments into a dictionary.\ndef add(*a):  return sum(a) \u0026gt;\u0026gt;\u0026gt; add(1, 2, 3) 6 Legal argument combinations:     def f(x, y, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(*, x, y, z): # f(x=1, y=2, z=3) def f(x, *, y, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(x, y, *, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) def f(*args): # f(1, 2, 3) def f(x, *args): # f(1, 2, 3) def f(*args, z): # f(1, 2, z=3) def f(x, *args, z): # f(1, 2, z=3) def f(**kwargs): # f(x=1, y=2, z=3) def f(x, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(*, x, **kwargs): # f(x=1, y=2, z=3) def f(*args, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(x, *args, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(*args, y, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(x, *args, z, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) Other Uses     \u0026lt;list\u0026gt; = [*\u0026lt;collection\u0026gt; [, ...]] \u0026lt;set\u0026gt; = {*\u0026lt;collection\u0026gt; [, ...]} \u0026lt;tuple\u0026gt; = (*\u0026lt;collection\u0026gt;, [...]) \u0026lt;dict\u0026gt; = {**\u0026lt;dict\u0026gt; [, ...]} head, *body, tail = \u0026lt;collection\u0026gt; Inline     Lambda     \u0026lt;function\u0026gt; = lambda: \u0026lt;return_value\u0026gt; \u0026lt;function\u0026gt; = lambda \u0026lt;argument_1\u0026gt;, \u0026lt;argument_2\u0026gt;: \u0026lt;return_value\u0026gt; Comprehension     \u0026lt;list\u0026gt; = [i+1 for i in range(10)] # [1, 2, ..., 10] \u0026lt;set\u0026gt; = {i for i in range(10) if i \u0026gt; 5} # {6, 7, 8, 9} \u0026lt;iter\u0026gt; = (i+5 for i in range(10)) # (5, 6, ..., 14) \u0026lt;dict\u0026gt; = {i: i*2 for i in range(10)} # {0: 0, 1: 2, ..., 9: 18} out = [i+j for i in range(10) for j in range(10)] Is the same as:     out = [] for i in range(10):  for j in range(10):  out.append(i+j) Map, Filter, Reduce     from functools import reduce \u0026lt;iter\u0026gt; = map(lambda x: x + 1, range(10)) # (1, 2, ..., 10) \u0026lt;iter\u0026gt; = filter(lambda x: x \u0026gt; 5, range(10)) # (6, 7, 8, 9) \u0026lt;obj\u0026gt; = reduce(lambda out, x: out + x, range(10)) # 45 Any, All     \u0026lt;bool\u0026gt; = any(\u0026lt;collection\u0026gt;) # False if empty. \u0026lt;bool\u0026gt; = all(el[1] for el in \u0026lt;collection\u0026gt;) # True if empty. If - Else     \u0026lt;obj\u0026gt; = \u0026lt;expression_if_true\u0026gt; if \u0026lt;condition\u0026gt; else \u0026lt;expression_if_false\u0026gt; \u0026gt;\u0026gt;\u0026gt; [a if a else \u0026#39;zero\u0026#39; for a in (0, 1, 2, 3)] [\u0026#39;zero\u0026#39;, 1, 2, 3] Namedtuple, Enum, Dataclass     from collections import namedtuple Point = namedtuple(\u0026#39;Point\u0026#39;, \u0026#39;x y\u0026#39;) point = Point(0, 0) from enum import Enum Direction = Enum(\u0026#39;Direction\u0026#39;, \u0026#39;n e s w\u0026#39;) direction = Direction.n from dataclasses import make_dataclass Creature = make_dataclass(\u0026#39;Creature\u0026#39;, [\u0026#39;location\u0026#39;, \u0026#39;direction\u0026#39;]) creature = Creature(Point(0, 0), Direction.n) Closure     We have a closure in Python when:\n A nested function references a value of its enclosing function and then the enclosing function returns the nested function.  def get_multiplier(a):  def out(b):  return a * b  return out \u0026gt;\u0026gt;\u0026gt; multiply_by_3 = get_multiplier(3) \u0026gt;\u0026gt;\u0026gt; multiply_by_3(10) 30  If multiple nested functions within enclosing function reference the same value, that value gets shared. To dynamically access function\u0026rsquo;s first free variable use '\u0026lt;function\u0026gt;.__closure__[0].cell_contents'.  Partial     from functools import partial \u0026lt;function\u0026gt; = partial(\u0026lt;function\u0026gt; [, \u0026lt;arg_1\u0026gt;, \u0026lt;arg_2\u0026gt;, ...]) \u0026gt;\u0026gt;\u0026gt; import operator as op \u0026gt;\u0026gt;\u0026gt; multiply_by_3 = partial(op.mul, 3) \u0026gt;\u0026gt;\u0026gt; multiply_by_3(10) 30  Partial is also useful in cases when function needs to be passed as an argument, because it enables us to set its arguments beforehand. A few examples being: 'defaultdict(\u0026lt;function\u0026gt;)', 'iter(\u0026lt;function\u0026gt;, to_exclusive)' and dataclass\u0026rsquo;s 'field(default_factory=\u0026lt;function\u0026gt;)'.  Non-Local     If variable is being assigned to anywhere in the scope, it is regarded as a local variable, unless it is declared as a \u0026lsquo;global\u0026rsquo; or a \u0026rsquo;nonlocal\u0026rsquo;.\ndef get_counter():  i = 0  def out():  nonlocal i  i += 1  return i  return out \u0026gt;\u0026gt;\u0026gt; counter = get_counter() \u0026gt;\u0026gt;\u0026gt; counter(), counter(), counter() (1, 2, 3) Decorator     A decorator takes a function, adds some functionality and returns it.\n@decorator_name def function_that_gets_passed_to_decorator():  ... Debugger Example     Decorator that prints function\u0026rsquo;s name every time it gets called.\nfrom functools import wraps  def debug(func):  @wraps(func)  def out(*args, **kwargs):  print(func.__name__)  return func(*args, **kwargs)  return out  @debug def add(x, y):  return x + y  Wraps is a helper decorator that copies the metadata of the passed function (func) to the function it is wrapping (out). Without it 'add.__name__' would return 'out'.  LRU Cache     Decorator that caches function\u0026rsquo;s return values. All function\u0026rsquo;s arguments must be hashable.\nfrom functools import lru_cache  @lru_cache(maxsize=None) def fib(n):  return n if n \u0026lt; 2 else fib(n-2) + fib(n-1)  CPython interpreter limits recursion depth to 1000 by default. To increase it use 'sys.setrecursionlimit(\u0026lt;depth\u0026gt;)'.  Parametrized Decorator     A decorator that accepts arguments and returns a normal decorator that accepts a function.\nfrom functools import wraps  def debug(print_result=False):  def decorator(func):  @wraps(func)  def out(*args, **kwargs):  result = func(*args, **kwargs)  print(func.__name__, result if print_result else \u0026#39;\u0026#39;)  return result  return out  return decorator  @debug(print_result=True) def add(x, y):  return x + y Class     class \u0026lt;name\u0026gt;:  def __init__(self, a):  self.a = a  def __repr__(self):  class_name = self.__class__.__name__  return f\u0026#39;{class_name}({self.a!r})\u0026#39;  def __str__(self):  return str(self.a)   @classmethod  def get_class_name(cls):  return cls.__name__  Return value of repr() should be unambiguous and of str() readable. If only repr() is defined, it will also be used for str().  Str() use cases:     print(\u0026lt;el\u0026gt;) print(f\u0026#39;{\u0026lt;el\u0026gt;}\u0026#39;) raise Exception(\u0026lt;el\u0026gt;) loguru.logger.debug(\u0026lt;el\u0026gt;) csv.writer(\u0026lt;file\u0026gt;).writerow([\u0026lt;el\u0026gt;]) Repr() use cases:     print([\u0026lt;el\u0026gt;]) print(f\u0026#39;{\u0026lt;el\u0026gt;!r}\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;el\u0026gt; loguru.logger.exception() Z = dataclasses.make_dataclass(\u0026#39;Z\u0026#39;, [\u0026#39;a\u0026#39;]); print(Z(\u0026lt;el\u0026gt;)) Constructor Overloading     class \u0026lt;name\u0026gt;:  def __init__(self, a=None):  self.a = a Inheritance     class Person:  def __init__(self, name, age):  self.name = name  self.age = age  class Employee(Person):  def __init__(self, name, age, staff_num):  super().__init__(name, age)  self.staff_num = staff_num Multiple Inheritance     class A: pass class B: pass class C(A, B): pass MRO determines the order in which parent classes are traversed when searching for a method:\n\u0026gt;\u0026gt;\u0026gt; C.mro() [\u0026lt;class \u0026#39;C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;] Property     Pythonic way of implementing getters and setters.\nclass MyClass:  @property  def a(self):  return self._a   @a.setter  def a(self, value):  self._a = value \u0026gt;\u0026gt;\u0026gt; el = MyClass() \u0026gt;\u0026gt;\u0026gt; el.a = 123 \u0026gt;\u0026gt;\u0026gt; el.a 123 Dataclass     Decorator that automatically generates init(), repr() and eq() special methods.\nfrom dataclasses import dataclass, field  @dataclass(order=False, frozen=False) class \u0026lt;class_name\u0026gt;:  \u0026lt;attr_name_1\u0026gt;: \u0026lt;type\u0026gt;  \u0026lt;attr_name_2\u0026gt;: \u0026lt;type\u0026gt; = \u0026lt;default_value\u0026gt;  \u0026lt;attr_name_3\u0026gt;: list/dict/set = field(default_factory=list/dict/set)  Objects can be made sortable with 'order=True' and/or immutable and hashable with 'frozen=True'. Function field() is needed because '\u0026lt;attr_name\u0026gt;: list = []' would make a list that is shared among all instances. Default_factory can be any callable.  Inline:     from dataclasses import make_dataclass \u0026lt;class\u0026gt; = make_dataclass(\u0026#39;\u0026lt;class_name\u0026gt;\u0026#39;, \u0026lt;coll_of_attribute_names\u0026gt;) \u0026lt;class\u0026gt; = make_dataclass(\u0026#39;\u0026lt;class_name\u0026gt;\u0026#39;, \u0026lt;coll_of_tuples\u0026gt;) \u0026lt;tuple\u0026gt; = (\u0026#39;\u0026lt;attr_name\u0026gt;\u0026#39;, \u0026lt;type\u0026gt; [, \u0026lt;default_value\u0026gt;]) Slots     Mechanism that restricts objects to attributes listed in \u0026lsquo;slots\u0026rsquo; and significantly reduces their memory footprint.\nclass MyClassWithSlots:  __slots__ = [\u0026#39;a\u0026#39;]  def __init__(self):  self.a = 1 Copy     from copy import copy, deepcopy \u0026lt;object\u0026gt; = copy(\u0026lt;object\u0026gt;) \u0026lt;object\u0026gt; = deepcopy(\u0026lt;object\u0026gt;) Duck Types     A duck type is an implicit type that prescribes a set of special methods. Any object that has those methods defined is considered a member of that duck type.\nComparable      If eq() method is not overridden, it returns 'id(self) == id(other)', which is the same as 'self is other'. That means all objects compare not equal by default. Only the left side object has eq() method called, unless it returns NotImplemented, in which case the right object is consulted.  class MyComparable:  def __init__(self, a):  self.a = a  def __eq__(self, other):  if isinstance(other, type(self)):  return self.a == other.a  return NotImplemented Hashable      Hashable object needs both hash() and eq() methods and its hash value should never change. Hashable objects that compare equal must have the same hash value, meaning default hash() that returns 'id(self)' will not do. That is why Python automatically makes classes unhashable if you only implement eq().  class MyHashable:  def __init__(self, a):  self._a = a  @property  def a(self):  return self._a  def __eq__(self, other):  if isinstance(other, type(self)):  return self.a == other.a  return NotImplemented  def __hash__(self):  return hash(self.a) Sortable      With total_ordering decorator, you only need to provide eq() and one of lt(), gt(), le() or ge() special methods.  from functools import total_ordering  @total_ordering class MySortable:  def __init__(self, a):  self.a = a  def __eq__(self, other):  if isinstance(other, type(self)):  return self.a == other.a  return NotImplemented  def __lt__(self, other):  if isinstance(other, type(self)):  return self.a \u0026lt; other.a  return NotImplemented Iterator      Any object that has methods next() and iter() is an iterator. Next() should return next item or raise StopIteration. Iter() should return \u0026lsquo;self\u0026rsquo;.  class Counter:  def __init__(self):  self.i = 0  def __next__(self):  self.i += 1  return self.i  def __iter__(self):  return self \u0026gt;\u0026gt;\u0026gt; counter = Counter() \u0026gt;\u0026gt;\u0026gt; next(counter), next(counter), next(counter) (1, 2, 3) Python has many different iterator objects:      Iterators returned by the iter() function, such as list_iterator and set_iterator. Objects returned by the itertools module, such as count, repeat and cycle. Generators returned by the generator functions and generator expressions. File objects returned by the open() function, etc.  Callable      All functions and classes have a call() method, hence are callable. When this cheatsheet uses '\u0026lt;function\u0026gt;' as an argument, it actually means '\u0026lt;callable\u0026gt;'.  class Counter:  def __init__(self):  self.i = 0  def __call__(self):  self.i += 1  return self.i \u0026gt;\u0026gt;\u0026gt; counter = Counter() \u0026gt;\u0026gt;\u0026gt; counter(), counter(), counter() (1, 2, 3) Context Manager      Enter() should lock the resources and optionally return an object. Exit() should release the resources. Any exception that happens inside the with block is passed to the exit() method. If it wishes to suppress the exception it must return a true value.  class MyOpen:  def __init__(self, filename):  self.filename = filename  def __enter__(self):  self.file = open(self.filename)  return self.file  def __exit__(self, exc_type, exception, traceback):  self.file.close() \u0026gt;\u0026gt;\u0026gt; with open(\u0026#39;test.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: ... file.write(\u0026#39;Hello World!\u0026#39;) \u0026gt;\u0026gt;\u0026gt; with MyOpen(\u0026#39;test.txt\u0026#39;) as file: ... print(file.read()) Hello World! Iterable Duck Types     Iterable      Only required method is iter(). It should return an iterator of object\u0026rsquo;s items. Contains() automatically works on any object that has iter() defined.  class MyIterable:  def __init__(self, a):  self.a = a  def __iter__(self):  return iter(self.a)  def __contains__(self, el):  return el in self.a \u0026gt;\u0026gt;\u0026gt; obj = MyIterable([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; [el for el in obj] [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; 1 in obj True Collection      Only required methods are iter() and len(). This cheatsheet actually means '\u0026lt;iterable\u0026gt;' when it uses '\u0026lt;collection\u0026gt;'. I chose not to use the name \u0026lsquo;iterable\u0026rsquo; because it sounds scarier and more vague than \u0026lsquo;collection\u0026rsquo;.  class MyCollection:  def __init__(self, a):  self.a = a  def __iter__(self):  return iter(self.a)  def __contains__(self, el):  return el in self.a  def __len__(self):  return len(self.a) Sequence      Only required methods are len() and getitem(). Getitem() should return an item at index or raise IndexError. Iter() and contains() automatically work on any object that has getitem() defined. Reversed() automatically works on any object that has getitem() and len() defined.  class MySequence:  def __init__(self, a):  self.a = a  def __iter__(self):  return iter(self.a)  def __contains__(self, el):  return el in self.a  def __len__(self):  return len(self.a)  def __getitem__(self, i):  return self.a[i]  def __reversed__(self):  return reversed(self.a) ABC Sequence      It\u0026rsquo;s a richer interface than the basic sequence. Extending it generates iter(), contains(), reversed(), index() and count(). Unlike 'abc.Iterable' and 'abc.Collection', it is not a duck type. That is why 'issubclass(MySequence, abc.Sequence)' would return False even if MySequence had all the methods defined.  from collections import abc  class MyAbcSequence(abc.Sequence):  def __init__(self, a):  self.a = a  def __len__(self):  return len(self.a)  def __getitem__(self, i):  return self.a[i] Table of required and automatically available special methods:     +------------+------------+------------+------------+--------------+ | | Iterable | Collection | Sequence | abc.Sequence | +------------+------------+------------+------------+--------------+ | iter() | REQ | REQ | Yes | Yes | | contains() | Yes | Yes | Yes | Yes | | len() | | REQ | REQ | REQ | | getitem() | | | REQ | REQ | | reversed() | | | Yes | Yes | | index() | | | | Yes | | count() | | | | Yes | +------------+------------+------------+------------+--------------+  Other ABCs that generate missing methods are: MutableSequence, Set, MutableSet, Mapping and MutableMapping. Names of their required methods are stored in '\u0026lt;abc\u0026gt;.__abstractmethods__'.  Enum     from enum import Enum, auto  class \u0026lt;enum_name\u0026gt;(Enum):  \u0026lt;member_name_1\u0026gt; = \u0026lt;value_1\u0026gt;  \u0026lt;member_name_2\u0026gt; = \u0026lt;value_2_a\u0026gt;, \u0026lt;value_2_b\u0026gt;  \u0026lt;member_name_3\u0026gt; = auto()  If there are no numeric values before auto(), it returns 1. Otherwise it returns an increment of the last numeric value.  \u0026lt;member\u0026gt; = \u0026lt;enum\u0026gt;.\u0026lt;member_name\u0026gt; # Returns a member. \u0026lt;member\u0026gt; = \u0026lt;enum\u0026gt;[\u0026#39;\u0026lt;member_name\u0026gt;\u0026#39;] # Returns a member or raises KeyError. \u0026lt;member\u0026gt; = \u0026lt;enum\u0026gt;(\u0026lt;value\u0026gt;) # Returns a member or raises ValueError. \u0026lt;str\u0026gt; = \u0026lt;member\u0026gt;.name # Returns member\u0026#39;s name. \u0026lt;obj\u0026gt; = \u0026lt;member\u0026gt;.value # Returns member\u0026#39;s value. list_of_members = list(\u0026lt;enum\u0026gt;) member_names = [a.name for a in \u0026lt;enum\u0026gt;] member_values = [a.value for a in \u0026lt;enum\u0026gt;] random_member = random.choice(list(\u0026lt;enum\u0026gt;)) def get_next_member(member):  members = list(member.__class__)  index = (members.index(member) + 1) % len(members)  return members[index] Inline     Cutlery = Enum(\u0026#39;Cutlery\u0026#39;, \u0026#39;fork knife spoon\u0026#39;) Cutlery = Enum(\u0026#39;Cutlery\u0026#39;, [\u0026#39;fork\u0026#39;, \u0026#39;knife\u0026#39;, \u0026#39;spoon\u0026#39;]) Cutlery = Enum(\u0026#39;Cutlery\u0026#39;, {\u0026#39;fork\u0026#39;: 1, \u0026#39;knife\u0026#39;: 2, \u0026#39;spoon\u0026#39;: 3}) User-defined functions cannot be values, so they must be wrapped:     from functools import partial LogicOp = Enum(\u0026#39;LogicOp\u0026#39;, {\u0026#39;AND\u0026#39;: partial(lambda l, r: l and r),  \u0026#39;OR\u0026#39; : partial(lambda l, r: l or r)})  Another solution in this particular case is to use built-in functions and_() and or_() from the module operator.  Exceptions     Basic Example     try:  \u0026lt;code\u0026gt; except \u0026lt;exception\u0026gt;:  \u0026lt;code\u0026gt; Complex Example     try:  \u0026lt;code_1\u0026gt; except \u0026lt;exception_a\u0026gt;:  \u0026lt;code_2_a\u0026gt; except \u0026lt;exception_b\u0026gt;:  \u0026lt;code_2_b\u0026gt; else:  \u0026lt;code_2_c\u0026gt; finally:  \u0026lt;code_3\u0026gt; Catching Exceptions     except \u0026lt;exception\u0026gt;: except \u0026lt;exception\u0026gt; as \u0026lt;name\u0026gt;: except (\u0026lt;exception\u0026gt;, ...): except (\u0026lt;exception\u0026gt;, ...) as \u0026lt;name\u0026gt;:  Also catches subclasses of the exception. Use 'traceback.print_exc()' to print the error message.  Raising Exceptions     raise \u0026lt;exception\u0026gt; raise \u0026lt;exception\u0026gt;() raise \u0026lt;exception\u0026gt;(\u0026lt;el\u0026gt; [, ...]) Re-raising caught exception:     except \u0026lt;exception\u0026gt; as \u0026lt;name\u0026gt;:  ...  raise Exception Object     arguments = \u0026lt;name\u0026gt;.args exc_type = \u0026lt;name\u0026gt;.__class__ filename = \u0026lt;name\u0026gt;.__traceback__.tb_frame.f_code.co_filename func_name = \u0026lt;name\u0026gt;.__traceback__.tb_frame.f_code.co_name line = linecache.getline(filename, \u0026lt;name\u0026gt;.__traceback__.tb_lineno) error_msg = traceback.format_exception(exc_type, \u0026lt;name\u0026gt;, \u0026lt;name\u0026gt;.__traceback__) Built-in Exceptions     BaseException  +-- SystemExit # Raised by the sys.exit() function.  +-- KeyboardInterrupt # Raised when the user hits the interrupt key (ctrl-c).  +-- Exception # User-defined exceptions should be derived from this class.  +-- ArithmeticError # Base class for arithmetic errors.  | +-- ZeroDivisionError # Raised when dividing by zero.  +-- AttributeError # Raised when an attribute is missing.  +-- EOFError # Raised by input() when it hits end-of-file condition.  +-- LookupError # Raised when a look-up on a collection fails.  | +-- IndexError # Raised when a sequence index is out of range.  | +-- KeyError # Raised when a dictionary key or set element is not found.  +-- NameError # Raised when a variable name is not found.  +-- OSError # Failures such as “file not found” or “disk full”.  | +-- FileNotFoundError # When a file or directory is requested but doesn\u0026#39;t exist.  +-- RuntimeError # Raised by errors that don\u0026#39;t fall into other categories.  | +-- RecursionError # Raised when the maximum recursion depth is exceeded.  +-- StopIteration # Raised by next() when run on an empty iterator.  +-- TypeError # Raised when an argument is of wrong type.  +-- ValueError # When an argument is of right type but inappropriate value.  +-- UnicodeError # Raised when encoding/decoding strings to/from bytes fails. Collections and their exceptions:     +-----------+------------+------------+------------+ | | list | dict | set | +-----------+------------+------------+------------+ | getitem() | IndexError | KeyError | | | pop() | IndexError | KeyError | KeyError | | remove() | ValueError | | KeyError | | index() | ValueError | | | +-----------+------------+------------+------------+ Useful built-in exceptions:     raise TypeError(\u0026#39;Argument is of wrong type!\u0026#39;) raise ValueError(\u0026#39;Argument is of right type but inappropriate value!\u0026#39;) raise RuntimeError(\u0026#39;None of above!\u0026#39;) User-defined Exceptions     class MyError(Exception):  pass  class MyInputError(MyError):  pass Exit     Exits the interpreter by raising SystemExit exception.\nimport sys sys.exit() # Exits with exit code 0 (success). sys.exit(\u0026lt;el\u0026gt;) # Prints to stderr and exits with 1. sys.exit(\u0026lt;int\u0026gt;) # Exits with passed exit code. Print     print(\u0026lt;el_1\u0026gt;, ..., sep=\u0026#39; \u0026#39;, end=\u0026#39;\\n\u0026#39;, file=sys.stdout, flush=False)  Use 'file=sys.stderr' for messages about errors. Use 'flush=True' to forcibly flush the stream.  Pretty Print     from pprint import pprint pprint(\u0026lt;collection\u0026gt;, width=80, depth=None, compact=False, sort_dicts=True)  Levels deeper than \u0026lsquo;depth\u0026rsquo; get replaced by \u0026lsquo;\u0026hellip;\u0026rsquo;.  Input     Reads a line from user input or pipe if present.\n\u0026lt;str\u0026gt; = input(prompt=None)  Trailing newline gets stripped. Prompt string is printed to the standard output before reading input. Raises EOFError when user hits EOF (ctrl-d/z) or input stream gets exhausted.  Command Line Arguments     import sys script_name = sys.argv[0] arguments = sys.argv[1:] Argument Parser     from argparse import ArgumentParser, FileType p = ArgumentParser(description=\u0026lt;str\u0026gt;) p.add_argument(\u0026#39;-\u0026lt;short_name\u0026gt;\u0026#39;, \u0026#39;--\u0026lt;name\u0026gt;\u0026#39;, action=\u0026#39;store_true\u0026#39;) # Flag p.add_argument(\u0026#39;-\u0026lt;short_name\u0026gt;\u0026#39;, \u0026#39;--\u0026lt;name\u0026gt;\u0026#39;, type=\u0026lt;type\u0026gt;) # Option p.add_argument(\u0026#39;\u0026lt;name\u0026gt;\u0026#39;, type=\u0026lt;type\u0026gt;, nargs=1) # First argument p.add_argument(\u0026#39;\u0026lt;name\u0026gt;\u0026#39;, type=\u0026lt;type\u0026gt;, nargs=\u0026#39;+\u0026#39;) # Remaining arguments p.add_argument(\u0026#39;\u0026lt;name\u0026gt;\u0026#39;, type=\u0026lt;type\u0026gt;, nargs=\u0026#39;*\u0026#39;) # Optional arguments args = p.parse_args() # Exits on error. value = args.\u0026lt;name\u0026gt;  Use 'help=\u0026lt;str\u0026gt;' to set argument description. Use 'default=\u0026lt;el\u0026gt;' to set the default value. Use 'type=FileType(\u0026lt;mode\u0026gt;)' for files.  Open     Opens the file and returns a corresponding file object.\n\u0026lt;file\u0026gt; = open(\u0026#39;\u0026lt;path\u0026gt;\u0026#39;, mode=\u0026#39;r\u0026#39;, encoding=None, newline=None)  'encoding=None' means that the default encoding is used, which is platform dependent. Best practice is to use 'encoding=\u0026quot;utf-8\u0026quot;' whenever possible. 'newline=None' means all different end of line combinations are converted to \u0026lsquo;\\n\u0026rsquo; on read, while on write all \u0026lsquo;\\n\u0026rsquo; characters are converted to system\u0026rsquo;s default line separator. 'newline=\u0026quot;\u0026quot;' means no conversions take place, but input is still broken into chunks by readline() and readlines() on either \u0026lsquo;\\n\u0026rsquo;, \u0026lsquo;\\r\u0026rsquo; or \u0026lsquo;\\r\\n\u0026rsquo;.  Modes      'r' - Read (default). 'w' - Write (truncate). 'x' - Write or fail if the file already exists. 'a' - Append. 'w+' - Read and write (truncate). 'r+' - Read and write from the start. 'a+' - Read and write from the end. 't' - Text mode (default). 'b' - Binary mode.  Exceptions      'FileNotFoundError' can be raised when reading with 'r' or 'r+'. 'FileExistsError' can be raised when writing with 'x'. 'IsADirectoryError' and 'PermissionError' can be raised by any. 'OSError' is the parent class of all listed exceptions.  File Object     \u0026lt;file\u0026gt;.seek(0) # Moves to the start of the file. \u0026lt;file\u0026gt;.seek(offset) # Moves \u0026#39;offset\u0026#39; chars/bytes from the start. \u0026lt;file\u0026gt;.seek(0, 2) # Moves to the end of the file. \u0026lt;bin_file\u0026gt;.seek(±offset, \u0026lt;anchor\u0026gt;) # Anchor: 0 start, 1 current position, 2 end. \u0026lt;str/bytes\u0026gt; = \u0026lt;file\u0026gt;.read(size=-1) # Reads \u0026#39;size\u0026#39; chars/bytes or until EOF. \u0026lt;str/bytes\u0026gt; = \u0026lt;file\u0026gt;.readline() # Returns a line or empty string/bytes on EOF. \u0026lt;list\u0026gt; = \u0026lt;file\u0026gt;.readlines() # Returns a list of remaining lines. \u0026lt;str/bytes\u0026gt; = next(\u0026lt;file\u0026gt;) # Returns a line using buffer. Do not mix. \u0026lt;file\u0026gt;.write(\u0026lt;str/bytes\u0026gt;) # Writes a string or bytes object. \u0026lt;file\u0026gt;.writelines(\u0026lt;collection\u0026gt;) # Writes a coll. of strings or bytes objects. \u0026lt;file\u0026gt;.flush() # Flushes write buffer.  Methods do not add or strip trailing newlines, even writelines().  Read Text from File     def read_file(filename):  with open(filename, encoding=\u0026#39;utf-8\u0026#39;) as file:  return file.readlines() Write Text to File     def write_to_file(filename, text):  with open(filename, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file:  file.write(text) Path     from os import getcwd, path, listdir from glob import glob \u0026lt;str\u0026gt; = getcwd() # Returns the current working directory. \u0026lt;str\u0026gt; = path.join(\u0026lt;path\u0026gt;, ...) # Joins two or more pathname components. \u0026lt;str\u0026gt; = path.abspath(\u0026lt;path\u0026gt;) # Returns absolute path. \u0026lt;str\u0026gt; = path.basename(\u0026lt;path\u0026gt;) # Returns final component of the path. \u0026lt;str\u0026gt; = path.dirname(\u0026lt;path\u0026gt;) # Returns path without the final component. \u0026lt;tup.\u0026gt; = path.splitext(\u0026lt;path\u0026gt;) # Splits on last period of the final component. \u0026lt;list\u0026gt; = listdir(path=\u0026#39;.\u0026#39;) # Returns filenames located at path. \u0026lt;list\u0026gt; = glob(\u0026#39;\u0026lt;pattern\u0026gt;\u0026#39;) # Returns paths matching the wildcard pattern. \u0026lt;bool\u0026gt; = path.exists(\u0026lt;path\u0026gt;) # Or: \u0026lt;Path\u0026gt;.exists() \u0026lt;bool\u0026gt; = path.isfile(\u0026lt;path\u0026gt;) # Or: \u0026lt;DirEntry/Path\u0026gt;.is_file() \u0026lt;bool\u0026gt; = path.isdir(\u0026lt;path\u0026gt;) # Or: \u0026lt;DirEntry/Path\u0026gt;.is_dir() DirEntry     Using scandir() instead of listdir() can significantly increase the performance of code that also needs file type information.\nfrom os import scandir \u0026lt;iter\u0026gt; = scandir(path=\u0026#39;.\u0026#39;) # Returns DirEntry objects located at path. \u0026lt;str\u0026gt; = \u0026lt;DirEntry\u0026gt;.path # Returns path as a string. \u0026lt;str\u0026gt; = \u0026lt;DirEntry\u0026gt;.name # Returns final component as a string. \u0026lt;file\u0026gt; = open(\u0026lt;DirEntry\u0026gt;) # Opens the file and returns file object. Path Object     from pathlib import Path \u0026lt;Path\u0026gt; = Path(\u0026lt;path\u0026gt; [, ...]) # Accepts strings, Paths and DirEntry objects. \u0026lt;Path\u0026gt; = \u0026lt;path\u0026gt; / \u0026lt;path\u0026gt; [/ ...] # One of the paths must be a Path object. \u0026lt;Path\u0026gt; = Path() # Returns relative cwd. Also Path(\u0026#39;.\u0026#39;). \u0026lt;Path\u0026gt; = Path.cwd() # Returns absolute cwd. Also Path().resolve(). \u0026lt;Path\u0026gt; = \u0026lt;Path\u0026gt;.resolve() # Returns absolute Path without symlinks. \u0026lt;Path\u0026gt; = \u0026lt;Path\u0026gt;.parent # Returns Path without final component. \u0026lt;str\u0026gt; = \u0026lt;Path\u0026gt;.name # Returns final component as a string. \u0026lt;str\u0026gt; = \u0026lt;Path\u0026gt;.stem # Returns final component without extension. \u0026lt;str\u0026gt; = \u0026lt;Path\u0026gt;.suffix # Returns final component\u0026#39;s extension. \u0026lt;tup.\u0026gt; = \u0026lt;Path\u0026gt;.parts # Returns all components as strings. \u0026lt;iter\u0026gt; = \u0026lt;Path\u0026gt;.iterdir() # Returns dir contents as Path objects. \u0026lt;iter\u0026gt; = \u0026lt;Path\u0026gt;.glob(\u0026#39;\u0026lt;pattern\u0026gt;\u0026#39;) # Returns Paths matching the wildcard pattern. \u0026lt;str\u0026gt; = str(\u0026lt;Path\u0026gt;) # Returns path as a string. \u0026lt;file\u0026gt; = open(\u0026lt;Path\u0026gt;) # Opens the file and returns file object. OS Commands     Files and Directories      Paths can be either strings, Paths or DirEntry objects. Functions report OS related errors by raising either OSError or one of its subclasses.  import os, shutil os.chdir(\u0026lt;path\u0026gt;) # Changes the current working directory. os.mkdir(\u0026lt;path\u0026gt;, mode=0o777) # Creates a directory. Mode is in octal. shutil.copy(from, to) # Copies the file. \u0026#39;to\u0026#39; can exist or be a dir. shutil.copytree(from, to) # Copies the directory. \u0026#39;to\u0026#39; must not exist. os.rename(from, to) # Renames/moves the file or directory. os.replace(from, to) # Same, but overwrites \u0026#39;to\u0026#39; if it exists. os.remove(\u0026lt;path\u0026gt;) # Deletes the file. os.rmdir(\u0026lt;path\u0026gt;) # Deletes the empty directory. shutil.rmtree(\u0026lt;path\u0026gt;) # Deletes the directory. Shell Commands     import os \u0026lt;str\u0026gt; = os.popen(\u0026#39;\u0026lt;shell_command\u0026gt;\u0026#39;).read() Sends \u0026lsquo;1 + 1\u0026rsquo; to the basic calculator and captures its output:     \u0026gt;\u0026gt;\u0026gt; from subprocess import run \u0026gt;\u0026gt;\u0026gt; run(\u0026#39;bc\u0026#39;, input=\u0026#39;1 + 1\\n\u0026#39;, capture_output=True, encoding=\u0026#39;utf-8\u0026#39;) CompletedProcess(args=\u0026#39;bc\u0026#39;, returncode=0, stdout=\u0026#39;2\\n\u0026#39;, stderr=\u0026#39;\u0026#39;) Sends test.in to the basic calculator running in standard mode and saves its output to test.out:     \u0026gt;\u0026gt;\u0026gt; from shlex import split \u0026gt;\u0026gt;\u0026gt; os.popen(\u0026#39;echo 1 + 1 \u0026gt; test.in\u0026#39;) \u0026gt;\u0026gt;\u0026gt; run(split(\u0026#39;bc -s\u0026#39;), stdin=open(\u0026#39;test.in\u0026#39;), stdout=open(\u0026#39;test.out\u0026#39;, \u0026#39;w\u0026#39;)) CompletedProcess(args=[\u0026#39;bc\u0026#39;, \u0026#39;-s\u0026#39;], returncode=0) \u0026gt;\u0026gt;\u0026gt; open(\u0026#39;test.out\u0026#39;).read() \u0026#39;2\\n\u0026#39; JSON     Text file format for storing collections of strings and numbers.\nimport json \u0026lt;str\u0026gt; = json.dumps(\u0026lt;object\u0026gt;, ensure_ascii=True, indent=None) \u0026lt;object\u0026gt; = json.loads(\u0026lt;str\u0026gt;) Read Object from JSON File     def read_json_file(filename):  with open(filename, encoding=\u0026#39;utf-8\u0026#39;) as file:  return json.load(file) Write Object to JSON File     def write_to_json_file(filename, an_object):  with open(filename, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file:  json.dump(an_object, file, ensure_ascii=False, indent=2) Pickle     Binary file format for storing objects.\nimport pickle \u0026lt;bytes\u0026gt; = pickle.dumps(\u0026lt;object\u0026gt;) \u0026lt;object\u0026gt; = pickle.loads(\u0026lt;bytes\u0026gt;) Read Object from File     def read_pickle_file(filename):  with open(filename, \u0026#39;rb\u0026#39;) as file:  return pickle.load(file) Write Object to File     def write_to_pickle_file(filename, an_object):  with open(filename, \u0026#39;wb\u0026#39;) as file:  pickle.dump(an_object, file) CSV     Text file format for storing spreadsheets.\nimport csv Read     \u0026lt;reader\u0026gt; = csv.reader(\u0026lt;file\u0026gt;, dialect=\u0026#39;excel\u0026#39;, delimiter=\u0026#39;,\u0026#39;) \u0026lt;list\u0026gt; = next(\u0026lt;reader\u0026gt;) # Returns next row as a list of strings. \u0026lt;list\u0026gt; = list(\u0026lt;reader\u0026gt;) # Returns list of remaining rows.  File must be opened with 'newline=\u0026quot;\u0026quot;' argument, or newlines embedded inside quoted fields will not be interpreted correctly!  Write     \u0026lt;writer\u0026gt; = csv.writer(\u0026lt;file\u0026gt;, dialect=\u0026#39;excel\u0026#39;, delimiter=\u0026#39;,\u0026#39;) \u0026lt;writer\u0026gt;.writerow(\u0026lt;collection\u0026gt;) # Encodes objects using `str(\u0026lt;el\u0026gt;)`. \u0026lt;writer\u0026gt;.writerows(\u0026lt;coll_of_coll\u0026gt;) # Appends multiple rows.  File must be opened with 'newline=\u0026quot;\u0026quot;' argument, or \u0026lsquo;\\r\u0026rsquo; will be added in front of every \u0026lsquo;\\n\u0026rsquo; on platforms that use \u0026lsquo;\\r\\n\u0026rsquo; line endings!  Parameters      'dialect' - Master parameter that sets the default values. 'delimiter' - A one-character string used to separate fields. 'quotechar' - Character for quoting fields that contain special characters. 'doublequote' - Whether quotechars inside fields get doubled or escaped. 'skipinitialspace' - Whether whitespace after delimiter gets stripped. 'lineterminator' - Specifies how writer terminates rows. 'quoting' - Controls the amount of quoting: 0 - as necessary, 1 - all. 'escapechar' - Character for escaping \u0026lsquo;quotechar\u0026rsquo; if \u0026lsquo;doublequote\u0026rsquo; is False.  Dialects     +------------------+--------------+--------------+--------------+ | | excel | excel-tab | unix | +------------------+--------------+--------------+--------------+ | delimiter | \u0026#39;,\u0026#39; | \u0026#39;\\t\u0026#39; | \u0026#39;,\u0026#39; | | quotechar | \u0026#39;\u0026#34;\u0026#39; | \u0026#39;\u0026#34;\u0026#39; | \u0026#39;\u0026#34;\u0026#39; | | doublequote | True | True | True | | skipinitialspace | False | False | False | | lineterminator | \u0026#39;\\r\\n\u0026#39; | \u0026#39;\\r\\n\u0026#39; | \u0026#39;\\n\u0026#39; | | quoting | 0 | 0 | 1 | | escapechar | None | None | None | +------------------+--------------+--------------+--------------+ Read Rows from CSV File     def read_csv_file(filename):  with open(filename, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\u0026#39;) as file:  return list(csv.reader(file)) Write Rows to CSV File     def write_to_csv_file(filename, rows):  with open(filename, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\u0026#39;) as file:  writer = csv.writer(file)  writer.writerows(rows) SQLite     Server-less database engine that stores each database into a separate file.\nConnect     Opens a connection to the database file. Creates a new file if path doesn\u0026rsquo;t exist.\nimport sqlite3 db = sqlite3.connect(\u0026#39;\u0026lt;path\u0026gt;\u0026#39;) # Also \u0026#39;:memory:\u0026#39;. ... db.close() Read     Returned values can be of type str, int, float, bytes or None.\n\u0026lt;cursor\u0026gt; = db.execute(\u0026#39;\u0026lt;query\u0026gt;\u0026#39;) # Can raise a subclass of sqlite3.Error. \u0026lt;tuple\u0026gt; = \u0026lt;cursor\u0026gt;.fetchone() # Returns next row. Also next(\u0026lt;cursor\u0026gt;). \u0026lt;list\u0026gt; = \u0026lt;cursor\u0026gt;.fetchall() # Returns remaining rows. Also list(\u0026lt;cursor\u0026gt;). Write     db.execute(\u0026#39;\u0026lt;query\u0026gt;\u0026#39;) db.commit() Or:     with db:  db.execute(\u0026#39;\u0026lt;query\u0026gt;\u0026#39;) Placeholders      Passed values can be of type str, int, float, bytes, None, bool, datetime.date or datetime.datetme. Bools will be stored and returned as ints and dates as ISO formatted strings.  db.execute(\u0026#39;\u0026lt;query\u0026gt;\u0026#39;, \u0026lt;list/tuple\u0026gt;) # Replaces \u0026#39;?\u0026#39;s in query with values. db.execute(\u0026#39;\u0026lt;query\u0026gt;\u0026#39;, \u0026lt;dict/namedtuple\u0026gt;) # Replaces \u0026#39;:\u0026lt;key\u0026gt;\u0026#39;s with values. db.executemany(\u0026#39;\u0026lt;query\u0026gt;\u0026#39;, \u0026lt;coll_of_above\u0026gt;) # Runs execute() many times. Example     In this example values are not actually saved because 'db.commit()' is omitted!\n\u0026gt;\u0026gt;\u0026gt; db = sqlite3.connect(\u0026#39;test.db\u0026#39;) \u0026gt;\u0026gt;\u0026gt; db.execute(\u0026#39;create table person (person_id integer primary key, name, height)\u0026#39;) \u0026gt;\u0026gt;\u0026gt; db.execute(\u0026#39;insert into person values (null, ?, ?)\u0026#39;, (\u0026#39;Jean-Luc\u0026#39;, 187)).lastrowid 1 \u0026gt;\u0026gt;\u0026gt; db.execute(\u0026#39;select * from person\u0026#39;).fetchall() [(1, \u0026#39;Jean-Luc\u0026#39;, 187)] MySQL     Has a very similar interface, with differences listed below.\n# $ pip3 install mysql-connector from mysql import connector db = connector.connect(host=\u0026lt;str\u0026gt;, user=\u0026lt;str\u0026gt;, password=\u0026lt;str\u0026gt;, database=\u0026lt;str\u0026gt;) \u0026lt;cursor\u0026gt; = db.cursor() \u0026lt;cursor\u0026gt;.execute(\u0026#39;\u0026lt;query\u0026gt;\u0026#39;) # Can raise a subclass of connector.Error. \u0026lt;cursor\u0026gt;.execute(\u0026#39;\u0026lt;query\u0026gt;\u0026#39;, \u0026lt;list/tuple\u0026gt;) # Replaces \u0026#39;%s\u0026#39;s in query with values. \u0026lt;cursor\u0026gt;.execute(\u0026#39;\u0026lt;query\u0026gt;\u0026#39;, \u0026lt;dict/namedtuple\u0026gt;) # Replaces \u0026#39;%(\u0026lt;key\u0026gt;)s\u0026#39;s with values. Bytes     Bytes object is an immutable sequence of single bytes. Mutable version is called bytearray.\n\u0026lt;bytes\u0026gt; = b\u0026#39;\u0026lt;str\u0026gt;\u0026#39; # Only accepts ASCII characters and \\x00 - \\xff. \u0026lt;int\u0026gt; = \u0026lt;bytes\u0026gt;[\u0026lt;index\u0026gt;] # Returns int in range from 0 to 255. \u0026lt;bytes\u0026gt; = \u0026lt;bytes\u0026gt;[\u0026lt;slice\u0026gt;] # Returns bytes even if it has only one element. \u0026lt;bytes\u0026gt; = \u0026lt;bytes\u0026gt;.join(\u0026lt;coll_of_bytes\u0026gt;) # Joins elements using bytes object as separator. Encode     \u0026lt;bytes\u0026gt; = bytes(\u0026lt;coll_of_ints\u0026gt;) # Ints must be in range from 0 to 255. \u0026lt;bytes\u0026gt; = bytes(\u0026lt;str\u0026gt;, \u0026#39;utf-8\u0026#39;) # Or: \u0026lt;str\u0026gt;.encode(\u0026#39;utf-8\u0026#39;) \u0026lt;bytes\u0026gt; = \u0026lt;int\u0026gt;.to_bytes(n_bytes, byteorder=\u0026#39;big/little\u0026#39;, signed=False) \u0026lt;bytes\u0026gt; = bytes.fromhex(\u0026#39;\u0026lt;hex\u0026gt;\u0026#39;) Decode     \u0026lt;list\u0026gt; = list(\u0026lt;bytes\u0026gt;) # Returns ints in range from 0 to 255. \u0026lt;str\u0026gt; = str(\u0026lt;bytes\u0026gt;, \u0026#39;utf-8\u0026#39;) # Or: \u0026lt;bytes\u0026gt;.decode(\u0026#39;utf-8\u0026#39;) \u0026lt;int\u0026gt; = int.from_bytes(\u0026lt;bytes\u0026gt;, byteorder=\u0026#39;big/little\u0026#39;, signed=False) \u0026#39;\u0026lt;hex\u0026gt;\u0026#39; = \u0026lt;bytes\u0026gt;.hex() Read Bytes from File     def read_bytes(filename):  with open(filename, \u0026#39;rb\u0026#39;) as file:  return file.read() Write Bytes to File     def write_bytes(filename, bytes_obj):  with open(filename, \u0026#39;wb\u0026#39;) as file:  file.write(bytes_obj) Struct      Module that performs conversions between a sequence of numbers and a bytes object. Machine’s native type sizes and byte order are used by default.  from struct import pack, unpack, iter_unpack \u0026lt;bytes\u0026gt; = pack(\u0026#39;\u0026lt;format\u0026gt;\u0026#39;, \u0026lt;num_1\u0026gt; [, \u0026lt;num_2\u0026gt;, ...]) \u0026lt;tuple\u0026gt; = unpack(\u0026#39;\u0026lt;format\u0026gt;\u0026#39;, \u0026lt;bytes\u0026gt;) \u0026lt;tuples\u0026gt; = iter_unpack(\u0026#39;\u0026lt;format\u0026gt;\u0026#39;, \u0026lt;bytes\u0026gt;) Example     \u0026gt;\u0026gt;\u0026gt; pack(\u0026#39;\u0026gt;hhl\u0026#39;, 1, 2, 3) b\u0026#39;\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03\u0026#39; \u0026gt;\u0026gt;\u0026gt; unpack(\u0026#39;\u0026gt;hhl\u0026#39;, b\u0026#39;\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03\u0026#39;) (1, 2, 3) Format     For standard type sizes start format string with:      '=' - native byte order '\u0026lt;' - little-endian '\u0026gt;' - big-endian (also '!')  Integer types. Use a capital letter for unsigned type. Standard sizes are in brackets:      'x' - pad byte 'b' - char (1) 'h' - short (2) 'i' - int (4) 'l' - long (4) 'q' - long long (8)  Floating point types:      'f' - float (4) 'd' - double (8)  Array     List that can only hold numbers of a predefined type. Available types and their sizes in bytes are listed above.\nfrom array import array \u0026lt;array\u0026gt; = array(\u0026#39;\u0026lt;typecode\u0026gt;\u0026#39;, \u0026lt;collection\u0026gt;) # Array from collection of numbers. \u0026lt;array\u0026gt; = array(\u0026#39;\u0026lt;typecode\u0026gt;\u0026#39;, \u0026lt;bytes\u0026gt;) # Array from bytes object. \u0026lt;array\u0026gt; = array(\u0026#39;\u0026lt;typecode\u0026gt;\u0026#39;, \u0026lt;array\u0026gt;) # Treats array as a sequence of numbers. \u0026lt;bytes\u0026gt; = bytes(\u0026lt;array\u0026gt;) # Or: \u0026lt;array\u0026gt;.tobytes() Memory View      A sequence object that points to the memory of another object. Each element can reference a single or multiple consecutive bytes, depending on format. Order and number of elements can be changed with slicing.  \u0026lt;mview\u0026gt; = memoryview(\u0026lt;bytes/bytearray/array\u0026gt;) # Immutable if bytes, else mutable. \u0026lt;real\u0026gt; = \u0026lt;mview\u0026gt;[\u0026lt;index\u0026gt;] # Returns an int or a float. \u0026lt;mview\u0026gt; = \u0026lt;mview\u0026gt;[\u0026lt;slice\u0026gt;] # Mview with rearranged elements. \u0026lt;mview\u0026gt; = \u0026lt;mview\u0026gt;.cast(\u0026#39;\u0026lt;typecode\u0026gt;\u0026#39;) # Casts memoryview to the new format. \u0026lt;mview\u0026gt;.release() # Releases the object\u0026#39;s memory buffer. Decode     \u0026lt;bin_file\u0026gt;.write(\u0026lt;mview\u0026gt;) # Writes mview to the binary file. \u0026lt;bytes\u0026gt; = bytes(\u0026lt;mview\u0026gt;) # Creates a new bytes object. \u0026lt;bytes\u0026gt; = \u0026lt;bytes\u0026gt;.join(\u0026lt;coll_of_mviews\u0026gt;) # Joins mviews using bytes object as sep. \u0026lt;array\u0026gt; = array(\u0026#39;\u0026lt;typecode\u0026gt;\u0026#39;, \u0026lt;mview\u0026gt;) # Treats mview as a sequence of numbers. \u0026lt;list\u0026gt; = list(\u0026lt;mview\u0026gt;) # Returns list of ints or floats. \u0026lt;str\u0026gt; = str(\u0026lt;mview\u0026gt;, \u0026#39;utf-8\u0026#39;) # Treats mview as a bytes object. \u0026lt;int\u0026gt; = int.from_bytes(\u0026lt;mview\u0026gt;, byteorder=\u0026#39;big/little\u0026#39;, signed=False) \u0026#39;\u0026lt;hex\u0026gt;\u0026#39; = \u0026lt;mview\u0026gt;.hex() Deque     A thread-safe list with efficient appends and pops from either side. Pronounced \u0026ldquo;deck\u0026rdquo;.\nfrom collections import deque \u0026lt;deque\u0026gt; = deque(\u0026lt;collection\u0026gt;, maxlen=None) \u0026lt;deque\u0026gt;.appendleft(\u0026lt;el\u0026gt;) # Opposite element is dropped if full. \u0026lt;deque\u0026gt;.extendleft(\u0026lt;collection\u0026gt;) # Collection gets reversed. \u0026lt;el\u0026gt; = \u0026lt;deque\u0026gt;.popleft() # Raises IndexError if empty. \u0026lt;deque\u0026gt;.rotate(n=1) # Rotates elements to the right. Threading      CPython interpreter can only run a single thread at a time. That is why using multiple threads won\u0026rsquo;t result in a faster execution, unless at least one of the threads contains an I/O operation.  from threading import Thread, RLock, Semaphore, Event, Barrier Thread     thread = Thread(target=\u0026lt;function\u0026gt;, args=(\u0026lt;first_arg\u0026gt;, )) thread.start() ... \u0026lt;bool\u0026gt; = thread.is_alive() # Checks if thread has finished executing. thread.join() # Waits for thread to finish.  Use 'kwargs=\u0026lt;dict\u0026gt;' to pass keyword arguments to the function. Use 'daemon=True', or the program will not be able to exit while the thread is alive.  Lock     lock = RLock() lock.acquire() # Waits for lock to be available. ... lock.release() Or:     lock = RLock() with lock:  ... Semaphore, Event, Barrier     \u0026lt;Semaphore\u0026gt; = Semaphore(value=1) # Lock that can be acquired \u0026#39;value\u0026#39; times. \u0026lt;Event\u0026gt; = Event() # Method wait() blocks until set() is called. \u0026lt;Barrier\u0026gt; = Barrier(n_times) # Method wait() blocks until it\u0026#39;s called \u0026#39;n_times\u0026#39;. Thread Pool Executor     from concurrent.futures import ThreadPoolExecutor with ThreadPoolExecutor(max_workers=None) as executor: # Does not exit until done.  \u0026lt;iter\u0026gt; = executor.map(lambda x: x + 1, range(3)) # (1, 2, 3)  \u0026lt;iter\u0026gt; = executor.map(lambda x, y: x + y, \u0026#39;abc\u0026#39;, \u0026#39;123\u0026#39;) # (\u0026#39;a1\u0026#39;, \u0026#39;b2\u0026#39;, \u0026#39;c3\u0026#39;)  \u0026lt;Future\u0026gt; = executor.submit(\u0026lt;function\u0026gt; [, \u0026lt;arg_1\u0026gt;, ...]) # Also visible outside block. Future:     \u0026lt;bool\u0026gt; = \u0026lt;Future\u0026gt;.done() # Checks if thread has finished executing. \u0026lt;obj\u0026gt; = \u0026lt;Future\u0026gt;.result() # Waits for thread to finish and returns result. Queue     A thread-safe FIFO queue. For LIFO queue use LifoQueue.\nfrom queue import Queue \u0026lt;Queue\u0026gt; = Queue(maxsize=0) \u0026lt;Queue\u0026gt;.put(\u0026lt;el\u0026gt;) # Blocks until queue stops being full. \u0026lt;Queue\u0026gt;.put_nowait(\u0026lt;el\u0026gt;) # Raises queue.Full exception if full. \u0026lt;el\u0026gt; = \u0026lt;Queue\u0026gt;.get() # Blocks until queue stops being empty. \u0026lt;el\u0026gt; = \u0026lt;Queue\u0026gt;.get_nowait() # Raises queue.Empty exception if empty. Operator     Module of functions that provide the functionality of operators.\nfrom operator import add, sub, mul, truediv, floordiv, mod, pow, neg, abs from operator import eq, ne, lt, le, gt, ge from operator import and_, or_, not_ from operator import itemgetter, attrgetter, methodcaller import operator as op elementwise_sum = map(op.add, list_a, list_b) sorted_by_second = sorted(\u0026lt;collection\u0026gt;, key=op.itemgetter(1)) sorted_by_both = sorted(\u0026lt;collection\u0026gt;, key=op.itemgetter(1, 0)) product_of_elems = functools.reduce(op.mul, \u0026lt;collection\u0026gt;) LogicOp = enum.Enum(\u0026#39;LogicOp\u0026#39;, {\u0026#39;AND\u0026#39;: op.and_, \u0026#39;OR\u0026#39; : op.or_}) last_el = op.methodcaller(\u0026#39;pop\u0026#39;)(\u0026lt;list\u0026gt;) Introspection     Inspecting code at runtime.\nVariables     \u0026lt;list\u0026gt; = dir() # Names of local variables (incl. functions). \u0026lt;dict\u0026gt; = vars() # Dict of local variables. Also locals(). \u0026lt;dict\u0026gt; = globals() # Dict of global variables. Attributes     \u0026lt;list\u0026gt; = dir(\u0026lt;object\u0026gt;) # Names of object\u0026#39;s attributes (incl. methods). \u0026lt;dict\u0026gt; = vars(\u0026lt;object\u0026gt;) # Dict of object\u0026#39;s fields. Also \u0026lt;obj\u0026gt;.__dict__. \u0026lt;bool\u0026gt; = hasattr(\u0026lt;object\u0026gt;, \u0026#39;\u0026lt;attr_name\u0026gt;\u0026#39;) value = getattr(\u0026lt;object\u0026gt;, \u0026#39;\u0026lt;attr_name\u0026gt;\u0026#39;) setattr(\u0026lt;object\u0026gt;, \u0026#39;\u0026lt;attr_name\u0026gt;\u0026#39;, value) delattr(\u0026lt;object\u0026gt;, \u0026#39;\u0026lt;attr_name\u0026gt;\u0026#39;) Parameters     from inspect import signature \u0026lt;sig\u0026gt; = signature(\u0026lt;function\u0026gt;) no_of_params = len(\u0026lt;sig\u0026gt;.parameters) param_names = list(\u0026lt;sig\u0026gt;.parameters.keys()) param_kinds = [a.kind for a in \u0026lt;sig\u0026gt;.parameters.values()] Metaprograming     Code that generates code.\nType     Type is the root class. If only passed an object it returns its type (class). Otherwise it creates a new class.\n\u0026lt;class\u0026gt; = type(\u0026#39;\u0026lt;class_name\u0026gt;\u0026#39;, \u0026lt;parents_tuple\u0026gt;, \u0026lt;attributes_dict\u0026gt;) \u0026gt;\u0026gt;\u0026gt; Z = type(\u0026#39;Z\u0026#39;, (), {\u0026#39;a\u0026#39;: \u0026#39;abcde\u0026#39;, \u0026#39;b\u0026#39;: 12345}) \u0026gt;\u0026gt;\u0026gt; z = Z() Meta Class     A class that creates classes.\ndef my_meta_class(name, parents, attrs):  attrs[\u0026#39;a\u0026#39;] = \u0026#39;abcde\u0026#39;  return type(name, parents, attrs) Or:     class MyMetaClass(type):  def __new__(cls, name, parents, attrs):  attrs[\u0026#39;a\u0026#39;] = \u0026#39;abcde\u0026#39;  return type.__new__(cls, name, parents, attrs)  New() is a class method that gets called before init(). If it returns an instance of its class, then that instance gets passed to init() as a \u0026lsquo;self\u0026rsquo; argument. It receives the same arguments as init(), except for the first one that specifies the desired type of the returned instance (MyMetaClass in our case). Like in our case, new() can also be called directly, usually from a new() method of a child class (def __new__(cls): return super().__new__(cls)). The only difference between the examples above is that my_meta_class() returns a class of type type, while MyMetaClass() returns a class of type MyMetaClass.  Metaclass Attribute     Right before a class is created it checks if it has the \u0026lsquo;metaclass\u0026rsquo; attribute defined. If not, it recursively checks if any of his parents has it defined and eventually comes to type().\nclass MyClass(metaclass=MyMetaClass):  b = 12345 \u0026gt;\u0026gt;\u0026gt; MyClass.a, MyClass.b (\u0026#39;abcde\u0026#39;, 12345) Type Diagram     type(MyClass) == MyMetaClass # MyClass is an instance of MyMetaClass. type(MyMetaClass) == type # MyMetaClass is an instance of type. +-------------+-------------+ | Classes | Metaclasses | +-------------+-------------| | MyClass --\u0026gt; MyMetaClass | | | v | | object -----\u0026gt; type \u0026lt;+ | | | ^ +--+ | | str ----------+ | +-------------+-------------+ Inheritance Diagram     MyClass.__base__ == object # MyClass is a subclass of object. MyMetaClass.__base__ == type # MyMetaClass is a subclass of type. +-------------+-------------+ | Classes | Metaclasses | +-------------+-------------| | MyClass | MyMetaClass | | v | v | | object \u0026lt;----- type | | ^ | | | str | | +-------------+-------------+ Eval     \u0026gt;\u0026gt;\u0026gt; from ast import literal_eval \u0026gt;\u0026gt;\u0026gt; literal_eval(\u0026#39;1 + 2\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; literal_eval(\u0026#39;[1, 2, 3]\u0026#39;) [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; literal_eval(\u0026#39;abs(1)\u0026#39;) ValueError: malformed node or string Coroutines      Coroutines have a lot in common with threads, but unlike threads, they only give up control when they call another coroutine and they don’t use as much memory. Coroutine definition starts with 'async' and its call with 'await'. 'asyncio.run(\u0026lt;coroutine\u0026gt;)' is the main entry point for asynchronous programs. Functions wait(), gather() and as_completed() can be used when multiple coroutines need to be started at the same time. Asyncio module also provides its own Queue, Event, Lock and Semaphore classes.  Runs a terminal game where you control an asterisk that must avoid numbers:     import asyncio, collections, curses, enum, random  P = collections.namedtuple(\u0026#39;P\u0026#39;, \u0026#39;x y\u0026#39;) # Position D = enum.Enum(\u0026#39;D\u0026#39;, \u0026#39;n e s w\u0026#39;) # Direction  def main(screen):  curses.curs_set(0) # Makes cursor invisible.  screen.nodelay(True) # Makes getch() non-blocking.  asyncio.run(main_coroutine(screen)) # Starts running asyncio code.  async def main_coroutine(screen):  state = {\u0026#39;*\u0026#39;: P(0, 0), **{id_: P(30, 10) for id_ in range(10)}}  moves = asyncio.Queue()  coros = (*(random_controller(id_, moves) for id_ in range(10)),  human_controller(screen, moves),  model(moves, state, *screen.getmaxyx()),  view(state, screen))  await asyncio.wait(coros, return_when=asyncio.FIRST_COMPLETED)  async def random_controller(id_, moves):  while True:  moves.put_nowait((id_, random.choice(list(D))))  await asyncio.sleep(random.random() / 2)  async def human_controller(screen, moves):  while True:  ch = screen.getch()  key_mappings = {259: D.n, 261: D.e, 258: D.s, 260: D.w}  if ch in key_mappings:  moves.put_nowait((\u0026#39;*\u0026#39;, key_mappings[ch]))  await asyncio.sleep(0.01)  async def model(moves, state, height, width):  while state[\u0026#39;*\u0026#39;] not in {p for id_, p in state.items() if id_ != \u0026#39;*\u0026#39;}:  id_, d = await moves.get()  p = state[id_]  deltas = {D.n: P(0, -1), D.e: P(1, 0), D.s: P(0, 1), D.w: P(-1, 0)}  new_p = P(*[sum(a) for a in zip(p, deltas[d])])  if 0 \u0026lt;= new_p.x \u0026lt; width-1 and 0 \u0026lt;= new_p.y \u0026lt; height:  state[id_] = new_p  async def view(state, screen):  while True:  screen.clear()  for id_, p in state.items():  screen.addstr(p.y, p.x, str(id_))  await asyncio.sleep(0.01)  curses.wrapper(main) Libraries     Progress Bar     # $ pip3 install tqdm from tqdm import tqdm from time import sleep for el in tqdm([1, 2, 3]):  sleep(0.2) Plot     # $ pip3 install matplotlib from matplotlib import pyplot pyplot.plot(\u0026lt;y_data\u0026gt; [, label=\u0026lt;str\u0026gt;]) pyplot.plot(\u0026lt;x_data\u0026gt;, \u0026lt;y_data\u0026gt;) pyplot.legend() # Adds a legend. pyplot.savefig(\u0026#39;\u0026lt;path\u0026gt;\u0026#39;) # Saves the figure. pyplot.show() # Displays the figure. pyplot.clf() # Clears the figure. Table     Prints a CSV file as an ASCII table:     # $ pip3 install tabulate import csv, tabulate with open(\u0026#39;test.csv\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\u0026#39;) as file:  rows = csv.reader(file)  header = [a.title() for a in next(rows)]  table = tabulate.tabulate(rows, header)  print(table) Curses     Clears the terminal, prints a message and waits for the ESC key press:     from curses import wrapper, curs_set, ascii from curses import KEY_UP, KEY_RIGHT, KEY_DOWN, KEY_LEFT  def main():  wrapper(draw)  def draw(screen):  curs_set(0) # Makes cursor invisible.  screen.nodelay(True) # Makes getch() non-blocking.  screen.clear()  screen.addstr(0, 0, \u0026#39;Press ESC to quit.\u0026#39;)  while screen.getch() != ascii.ESC:  pass  def get_border(screen):  from collections import namedtuple  P = namedtuple(\u0026#39;P\u0026#39;, \u0026#39;x y\u0026#39;)  height, width = screen.getmaxyx()  return P(width-1, height-1)  if __name__ == \u0026#39;__main__\u0026#39;:  main() Logging     # $ pip3 install loguru from loguru import logger logger.add(\u0026#39;debug_{time}.log\u0026#39;, colorize=True) # Connects a log file. logger.add(\u0026#39;error_{time}.log\u0026#39;, level=\u0026#39;ERROR\u0026#39;) # Another file for errors or higher. logger.\u0026lt;level\u0026gt;(\u0026#39;A logging message.\u0026#39;)  Levels: 'debug', 'info', 'success', 'warning', 'error', 'critical'.  Exceptions     Exception description, stack trace and values of variables are appended automatically.\ntry:  ... except \u0026lt;exception\u0026gt;:  logger.exception(\u0026#39;An error happened.\u0026#39;) Rotation     Argument that sets a condition when a new log file is created.\nrotation=\u0026lt;int\u0026gt;|\u0026lt;datetime.timedelta\u0026gt;|\u0026lt;datetime.time\u0026gt;|\u0026lt;str\u0026gt;  '\u0026lt;int\u0026gt;' - Max file size in bytes. '\u0026lt;timedelta\u0026gt;' - Max age of a file. '\u0026lt;time\u0026gt;' - Time of day. '\u0026lt;str\u0026gt;' - Any of above as a string: '100 MB', '1 month', 'monday at 12:00', \u0026hellip;  Retention     Sets a condition which old log files get deleted.\nretention=\u0026lt;int\u0026gt;|\u0026lt;datetime.timedelta\u0026gt;|\u0026lt;str\u0026gt;  '\u0026lt;int\u0026gt;' - Max number of files. '\u0026lt;timedelta\u0026gt;' - Max age of a file. '\u0026lt;str\u0026gt;' - Max age as a string: '1 week, 3 days', '2 months', \u0026hellip;  Scraping     Scrapes Python\u0026rsquo;s URL, version number and logo from Wikipedia page:     # $ pip3 install requests beautifulsoup4 import requests from bs4 import BeautifulSoup URL = \u0026#39;https://en.wikipedia.org/wiki/Python_(programming_language)\u0026#39; try:  html = requests.get(URL).text  doc = BeautifulSoup(html, \u0026#39;html.parser\u0026#39;)  table = doc.find(\u0026#39;table\u0026#39;, class_=\u0026#39;infobox vevent\u0026#39;)  rows = table.find_all(\u0026#39;tr\u0026#39;)  link = rows[11].find(\u0026#39;a\u0026#39;)[\u0026#39;href\u0026#39;]  ver = rows[6].find(\u0026#39;div\u0026#39;).text.split()[0]  url_i = rows[0].find(\u0026#39;img\u0026#39;)[\u0026#39;src\u0026#39;]  image = requests.get(f\u0026#39;https:{url_i}\u0026#39;).content  with open(\u0026#39;test.png\u0026#39;, \u0026#39;wb\u0026#39;) as file:  file.write(image)  print(link, ver) except requests.exceptions.ConnectionError:  print(\u0026#34;You\u0026#39;ve got problems with connection.\u0026#34;) Web     # $ pip3 install bottle from bottle import run, route, static_file, template, post, request, response import json Run     run(host=\u0026#39;localhost\u0026#39;, port=8080) # Runs locally. run(host=\u0026#39;0.0.0.0\u0026#39;, port=80) # Runs globally. Static Request     @route(\u0026#39;/img/\u0026lt;image\u0026gt;\u0026#39;) def send_image(image):  return static_file(image, \u0026#39;img_dir/\u0026#39;, mimetype=\u0026#39;image/png\u0026#39;) Dynamic Request     @route(\u0026#39;/\u0026lt;sport\u0026gt;\u0026#39;) def send_page(sport):  return template(\u0026#39;\u0026lt;h1\u0026gt;{{title}}\u0026lt;/h1\u0026gt;\u0026#39;, title=sport) REST Request     @post(\u0026#39;/odds/\u0026lt;sport\u0026gt;\u0026#39;) def odds_handler(sport):  team = request.forms.get(\u0026#39;team\u0026#39;)  home_odds, away_odds = 2.44, 3.29  response.headers[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/json\u0026#39;  response.headers[\u0026#39;Cache-Control\u0026#39;] = \u0026#39;no-cache\u0026#39;  return json.dumps([team, home_odds, away_odds]) Test:     # $ pip3 install requests \u0026gt;\u0026gt;\u0026gt; import requests \u0026gt;\u0026gt;\u0026gt; url = \u0026#39;http://localhost:8080/odds/football\u0026#39; \u0026gt;\u0026gt;\u0026gt; data = {\u0026#39;team\u0026#39;: \u0026#39;arsenal f.c.\u0026#39;} \u0026gt;\u0026gt;\u0026gt; response = requests.post(url, data=data) \u0026gt;\u0026gt;\u0026gt; response.json() [\u0026#39;arsenal f.c.\u0026#39;, 2.44, 3.29] Profiling     Stopwatch     from time import time start_time = time() # Seconds since the Epoch. ... duration = time() - start_time High performance:     from time import perf_counter start_time = perf_counter() # Seconds since restart. ... duration = perf_counter() - start_time Timing a Snippet     \u0026gt;\u0026gt;\u0026gt; from timeit import timeit \u0026gt;\u0026gt;\u0026gt; timeit(\u0026#39;\u0026#34;-\u0026#34;.join(str(a) for a in range(100))\u0026#39;, ... number=10000, globals=globals(), setup=\u0026#39;pass\u0026#39;) 0.34986 Profiling by Line     # $ pip3 install line_profiler memory_profiler @profile def main():  a = [*range(10000)]  b = {*range(10000)} main() $ kernprof -lv test.py Line # Hits Time Per Hit % Time Line Contents =======================================================  1 @profile  2 def main():  3 1 1128.0 1128.0 27.4 a = [*range(10000)]  4 1 2994.0 2994.0 72.6 b = {*range(10000)} $ python3 -m memory_profiler test.py Line # Mem usage Increment Line Contents =======================================================  1 35.387 MiB 35.387 MiB @profile  2 def main():  3 35.734 MiB 0.348 MiB a = [*range(10000)]  4 36.160 MiB 0.426 MiB b = {*range(10000)} Call Graph     Generates a PNG image of a call graph with highlighted bottlenecks:     # $ pip3 install pycallgraph from pycallgraph import output, PyCallGraph from datetime import datetime time_str = datetime.now().strftime(\u0026#39;%Y%m%d%H%M%S\u0026#39;) filename = f\u0026#39;profile-{time_str}.png\u0026#39; drawer = output.GraphvizOutput(output_file=filename) with PyCallGraph(drawer):  \u0026lt;code_to_be_profiled\u0026gt; NumPy     Array manipulation mini-language. It can run up to one hundred times faster than the equivalent Python code.\n# $ pip3 install numpy import numpy as np \u0026lt;array\u0026gt; = np.array(\u0026lt;list\u0026gt;) \u0026lt;array\u0026gt; = np.arange(from_inclusive, to_exclusive, ±step_size) \u0026lt;array\u0026gt; = np.ones(\u0026lt;shape\u0026gt;) \u0026lt;array\u0026gt; = np.random.randint(from_inclusive, to_exclusive, \u0026lt;shape\u0026gt;) \u0026lt;array\u0026gt;.shape = \u0026lt;shape\u0026gt; \u0026lt;view\u0026gt; = \u0026lt;array\u0026gt;.reshape(\u0026lt;shape\u0026gt;) \u0026lt;view\u0026gt; = np.broadcast_to(\u0026lt;array\u0026gt;, \u0026lt;shape\u0026gt;) \u0026lt;array\u0026gt; = \u0026lt;array\u0026gt;.sum(axis) indexes = \u0026lt;array\u0026gt;.argmin(axis)  Shape is a tuple of dimension sizes. Axis is the index of a dimension that gets collapsed. The leftmost dimension has index 0.  Indexing     \u0026lt;el\u0026gt; = \u0026lt;2d_array\u0026gt;[0, 0] # First element. \u0026lt;1d_view\u0026gt; = \u0026lt;2d_array\u0026gt;[0] # First row. \u0026lt;1d_view\u0026gt; = \u0026lt;2d_array\u0026gt;[:, 0] # First column. Also [..., 0]. \u0026lt;3d_view\u0026gt; = \u0026lt;2d_array\u0026gt;[None, :, :] # Expanded by dimension of size 1. \u0026lt;1d_array\u0026gt; = \u0026lt;2d_array\u0026gt;[\u0026lt;1d_row_indexes\u0026gt;, \u0026lt;1d_column_indexes\u0026gt;] \u0026lt;2d_array\u0026gt; = \u0026lt;2d_array\u0026gt;[\u0026lt;2d_row_indexes\u0026gt;, \u0026lt;2d_column_indexes\u0026gt;] \u0026lt;2d_bools\u0026gt; = \u0026lt;2d_array\u0026gt; \u0026gt; 0 \u0026lt;1d_array\u0026gt; = \u0026lt;2d_array\u0026gt;[\u0026lt;2d_bools\u0026gt;]  If row and column indexes differ in shape, they are combined with broadcasting.  Broadcasting     Broadcasting is a set of rules by which NumPy functions operate on arrays of different sizes and/or dimensions.\nleft = [[0.1], [0.6], [0.8]] # Shape: (3, 1) right = [ 0.1 , 0.6 , 0.8 ] # Shape: (3) 1. If array shapes differ in length, left-pad the shorter shape with ones:     left = [[0.1], [0.6], [0.8]] # Shape: (3, 1) right = [[0.1 , 0.6 , 0.8]] # Shape: (1, 3) \u0026lt;- ! 2. If any dimensions differ in size, expand the ones that have size 1 by duplicating their elements:     left = [[0.1, 0.1, 0.1], [0.6, 0.6, 0.6], [0.8, 0.8, 0.8]] # Shape: (3, 3) \u0026lt;- ! right = [[0.1, 0.6, 0.8], [0.1, 0.6, 0.8], [0.1, 0.6, 0.8]] # Shape: (3, 3) \u0026lt;- ! 3. If neither non-matching dimension has size 1, raise an error.     Example     For each point returns index of its nearest point ([0.1, 0.6, 0.8] =\u0026gt; [1, 2, 1]):     \u0026gt;\u0026gt;\u0026gt; points = np.array([0.1, 0.6, 0.8])  [ 0.1, 0.6, 0.8] \u0026gt;\u0026gt;\u0026gt; wrapped_points = points.reshape(3, 1) [[ 0.1],  [ 0.6],  [ 0.8]] \u0026gt;\u0026gt;\u0026gt; distances = wrapped_points - points [[ 0. , -0.5, -0.7],  [ 0.5, 0. , -0.2],  [ 0.7, 0.2, 0. ]] \u0026gt;\u0026gt;\u0026gt; distances = np.abs(distances) [[ 0. , 0.5, 0.7],  [ 0.5, 0. , 0.2],  [ 0.7, 0.2, 0. ]] \u0026gt;\u0026gt;\u0026gt; i = np.arange(3) [0, 1, 2] \u0026gt;\u0026gt;\u0026gt; distances[i, i] = np.inf [[ inf, 0.5, 0.7],  [ 0.5, inf, 0.2],  [ 0.7, 0.2, inf]] \u0026gt;\u0026gt;\u0026gt; distances.argmin(1) [1, 2, 1] Image     # $ pip3 install pillow from PIL import Image \u0026lt;Image\u0026gt; = Image.new(\u0026#39;\u0026lt;mode\u0026gt;\u0026#39;, (width, height)) \u0026lt;Image\u0026gt; = Image.open(\u0026#39;\u0026lt;path\u0026gt;\u0026#39;) \u0026lt;Image\u0026gt; = \u0026lt;Image\u0026gt;.convert(\u0026#39;\u0026lt;mode\u0026gt;\u0026#39;) \u0026lt;Image\u0026gt;.save(\u0026#39;\u0026lt;path\u0026gt;\u0026#39;) \u0026lt;Image\u0026gt;.show() \u0026lt;tuple/int\u0026gt; = \u0026lt;Image\u0026gt;.getpixel((x, y)) # Returns a pixel. \u0026lt;Image\u0026gt;.putpixel((x, y), \u0026lt;tuple/int\u0026gt;) # Writes a pixel to the image. \u0026lt;ImagingCore\u0026gt; = \u0026lt;Image\u0026gt;.getdata() # Returns a sequence of pixels. \u0026lt;Image\u0026gt;.putdata(\u0026lt;list/ImagingCore\u0026gt;) # Writes a sequence of pixels. \u0026lt;Image\u0026gt;.paste(\u0026lt;Image\u0026gt;, (x, y)) # Writes an image to the image. \u0026lt;2d_array\u0026gt; = np.array(\u0026lt;Image\u0026gt;) # Creates NumPy array from greyscale image. \u0026lt;3d_array\u0026gt; = np.array(\u0026lt;Image\u0026gt;) # Creates NumPy array from color image. \u0026lt;Image\u0026gt; = Image.fromarray(\u0026lt;array\u0026gt;) # Creates image from NumPy array of floats. Modes      '1' - 1-bit pixels, black and white, stored with one pixel per byte. 'L' - 8-bit pixels, greyscale. 'RGB' - 3x8-bit pixels, true color. 'RGBA' - 4x8-bit pixels, true color with transparency mask. 'HSV' - 3x8-bit pixels, Hue, Saturation, Value color space.  Examples     Creates a PNG image of a rainbow gradient:     WIDTH, HEIGHT = 100, 100 size = WIDTH * HEIGHT hues = [255 * i/size for i in range(size)] img = Image.new(\u0026#39;HSV\u0026#39;, (WIDTH, HEIGHT)) img.putdata([(int(h), 255, 255) for h in hues]) img.convert(\u0026#39;RGB\u0026#39;).save(\u0026#39;test.png\u0026#39;) Adds noise to a PNG image:     from random import randint add_noise = lambda value: max(0, min(255, value + randint(-20, 20))) img = Image.open(\u0026#39;test.png\u0026#39;).convert(\u0026#39;HSV\u0026#39;) img.putdata([(add_noise(h), s, v) for h, s, v in img.getdata()]) img.convert(\u0026#39;RGB\u0026#39;).save(\u0026#39;test.png\u0026#39;) Drawing     from PIL import ImageDraw \u0026lt;ImageDraw\u0026gt; = ImageDraw.Draw(\u0026lt;Image\u0026gt;) \u0026lt;ImageDraw\u0026gt;.point((x, y), fill=None) \u0026lt;ImageDraw\u0026gt;.line((x1, y1, x2, y2 [, ...]), fill=None, width=0, joint=None) \u0026lt;ImageDraw\u0026gt;.arc((x1, y1, x2, y2), from_deg, to_deg, fill=None, width=0) \u0026lt;ImageDraw\u0026gt;.rectangle((x1, y1, x2, y2), fill=None, outline=None, width=0) \u0026lt;ImageDraw\u0026gt;.polygon((x1, y1, x2, y2 [, ...]), fill=None, outline=None) \u0026lt;ImageDraw\u0026gt;.ellipse((x1, y1, x2, y2), fill=None, outline=None, width=0)  Use 'fill=\u0026lt;color\u0026gt;' to set the primary color. Use 'outline=\u0026lt;color\u0026gt;' to set the secondary color. Color can be specified as a tuple, int, '#rrggbb' string or a color name.  Animation     Creates a GIF of a bouncing ball:     # $ pip3 install pillow imageio from PIL import Image, ImageDraw import imageio WIDTH, R = 126, 10 frames = [] for velocity in range(15):  y = sum(range(velocity+1))  frame = Image.new(\u0026#39;L\u0026#39;, (WIDTH, WIDTH))  draw = ImageDraw.Draw(frame)  draw.ellipse((WIDTH/2-R, y, WIDTH/2+R, y+R*2), fill=\u0026#39;white\u0026#39;)  frames.append(frame) frames += reversed(frames[1:-1]) imageio.mimsave(\u0026#39;test.gif\u0026#39;, frames, duration=0.03) Audio     import wave \u0026lt;Wave_read\u0026gt; = wave.open(\u0026#39;\u0026lt;path\u0026gt;\u0026#39;, \u0026#39;rb\u0026#39;) # Opens the WAV file. framerate = \u0026lt;Wave_read\u0026gt;.getframerate() # Number of frames per second. nchannels = \u0026lt;Wave_read\u0026gt;.getnchannels() # Number of samples per frame. sampwidth = \u0026lt;Wave_read\u0026gt;.getsampwidth() # Sample size in bytes. nframes = \u0026lt;Wave_read\u0026gt;.getnframes() # Number of frames. \u0026lt;params\u0026gt; = \u0026lt;Wave_read\u0026gt;.getparams() # Immutable collection of above. \u0026lt;bytes\u0026gt; = \u0026lt;Wave_read\u0026gt;.readframes(nframes) # Returns next \u0026#39;nframes\u0026#39; frames. \u0026lt;Wave_write\u0026gt; = wave.open(\u0026#39;\u0026lt;path\u0026gt;\u0026#39;, \u0026#39;wb\u0026#39;) # Truncates existing file. \u0026lt;Wave_write\u0026gt;.setframerate(\u0026lt;int\u0026gt;) # 44100 for CD, 48000 for video. \u0026lt;Wave_write\u0026gt;.setnchannels(\u0026lt;int\u0026gt;) # 1 for mono, 2 for stereo. \u0026lt;Wave_write\u0026gt;.setsampwidth(\u0026lt;int\u0026gt;) # 2 for CD quality sound. \u0026lt;Wave_write\u0026gt;.setparams(\u0026lt;params\u0026gt;) # Sets all parameters. \u0026lt;Wave_write\u0026gt;.writeframes(\u0026lt;bytes\u0026gt;) # Appends frames to the file.  Bytes object contains a sequence of frames, each consisting of one or more samples. In a stereo signal, the first sample of a frame belongs to the left channel. Each sample consists of one or more bytes that, when converted to an integer, indicate the displacement of a speaker membrane at a given moment. If sample width is one, then the integer should be encoded unsigned. For all other sizes, the integer should be encoded signed with little-endian byte order.  Sample Values     +-----------+-------------+------+-------------+ | sampwidth | min | zero | max | +-----------+-------------+------+-------------+ | 1 | 0 | 128 | 255 | | 2 | -32768 | 0 | 32767 | | 3 | -8388608 | 0 | 8388607 | | 4 | -2147483648 | 0 | 2147483647 | +-----------+-------------+------+-------------+ Read Float Samples from WAV File     def read_wav_file(filename):  def get_int(a_bytes):  an_int = int.from_bytes(a_bytes, \u0026#39;little\u0026#39;, signed=width!=1)  return an_int - 128 * (width == 1)  with wave.open(filename, \u0026#39;rb\u0026#39;) as file:  width = file.getsampwidth()  frames = file.readframes(file.getnframes())  byte_samples = (frames[i: i + width] for i in range(0, len(frames), width))  return [get_int(b) / pow(2, width * 8 - 1) for b in byte_samples] Write Float Samples to WAV File     def write_to_wav_file(filename, float_samples, nchannels=1, sampwidth=2, framerate=44100):  def get_bytes(a_float):  a_float = max(-1, min(1 - 2e-16, a_float))  a_float += sampwidth == 1  a_float *= pow(2, sampwidth * 8 - 1)  return int(a_float).to_bytes(sampwidth, \u0026#39;little\u0026#39;, signed=sampwidth!=1)  with wave.open(filename, \u0026#39;wb\u0026#39;) as file:  file.setnchannels(nchannels)  file.setsampwidth(sampwidth)  file.setframerate(framerate)  file.writeframes(b\u0026#39;\u0026#39;.join(get_bytes(f) for f in float_samples)) Examples     Saves a sine wave to a mono WAV file:     from math import pi, sin samples_f = (sin(i * 2 * pi * 440 / 44100) for i in range(100000)) write_to_wav_file(\u0026#39;test.wav\u0026#39;, samples_f) Adds noise to a mono WAV file:     from random import random add_noise = lambda value: value + (random() - 0.5) * 0.03 samples_f = (add_noise(f) for f in read_wav_file(\u0026#39;test.wav\u0026#39;)) write_to_wav_file(\u0026#39;test.wav\u0026#39;, samples_f) Plays a WAV file:     # $ pip3 install simpleaudio from simpleaudio import play_buffer with wave.open(\u0026#39;test.wav\u0026#39;, \u0026#39;rb\u0026#39;) as file:  p = file.getparams()  frames = file.readframes(p.nframes)  play_buffer(frames, p.nchannels, p.sampwidth, p.framerate) Text to Speech     # $ pip3 install pyttsx3 import pyttsx3 engine = pyttsx3.init() engine.say(\u0026#39;Sally sells seashells by the seashore.\u0026#39;) engine.runAndWait() Synthesizer     Plays Popcorn by Gershon Kingsley:     # $ pip3 install simpleaudio import simpleaudio, math, struct from itertools import chain, repeat F = 44100 P1 = \u0026#39;71♪,69,,71♪,66,,62♪,66,,59♪,,,\u0026#39; P2 = \u0026#39;71♪,73,,74♪,73,,74,,71,,73♪,71,,73,,69,,71♪,69,,71,,67,,71♪,,,\u0026#39; get_pause = lambda seconds: repeat(0, int(seconds * F)) sin_f = lambda i, hz: math.sin(i * 2 * math.pi * hz / F) get_wave = lambda hz, seconds: (sin_f(i, hz) for i in range(int(seconds * F))) get_hz = lambda key: 8.176 * 2 ** (int(key) / 12) parse_note = lambda note: (get_hz(note[:2]), 0.25 if \u0026#39;♪\u0026#39; in note else 0.125) get_samples = lambda note: get_wave(*parse_note(note)) if note else get_pause(0.125) samples_f = chain.from_iterable(get_samples(n) for n in f\u0026#39;{P1}{P1}{P2}\u0026#39;.split(\u0026#39;,\u0026#39;)) samples_b = b\u0026#39;\u0026#39;.join(struct.pack(\u0026#39;\u0026lt;h\u0026#39;, int(f * 30000)) for f in samples_f) simpleaudio.play_buffer(samples_b, 1, 2, F) Pygame     Basic Example     # $ pip3 install pygame import pygame as pg pg.init() screen = pg.display.set_mode((500, 500)) rect = pg.Rect(240, 240, 20, 20) while all(event.type != pg.QUIT for event in pg.event.get()):  deltas = {pg.K_UP: (0, -3), pg.K_RIGHT: (3, 0), pg.K_DOWN: (0, 3), pg.K_LEFT: (-3, 0)}  for delta in (deltas.get(i) for i, on in enumerate(pg.key.get_pressed()) if on):  rect = rect.move(delta) if delta else rect  screen.fill((0, 0, 0))  pg.draw.rect(screen, (255, 255, 255), rect)  pg.display.flip() Rectangle     Object for storing rectangular coordinates.\n\u0026lt;Rect\u0026gt; = pg.Rect(x, y, width, height) \u0026lt;int\u0026gt; = \u0026lt;Rect\u0026gt;.x/y/centerx/centery/… \u0026lt;tup.\u0026gt; = \u0026lt;Rect\u0026gt;.topleft/center/… \u0026lt;Rect\u0026gt; = \u0026lt;Rect\u0026gt;.move((x, y)) \u0026lt;bool\u0026gt; = \u0026lt;Rect\u0026gt;.collidepoint((x, y)) # Tests if a point is inside a rectangle. \u0026lt;bool\u0026gt; = \u0026lt;Rect\u0026gt;.colliderect(\u0026lt;Rect\u0026gt;) # Tests if two rectangles overlap. \u0026lt;int\u0026gt; = \u0026lt;Rect\u0026gt;.collidelist(\u0026lt;list_of_Rect\u0026gt;) # Returns index of first colliding Rect or -1. \u0026lt;list\u0026gt; = \u0026lt;Rect\u0026gt;.collidelistall(\u0026lt;list_of_Rect\u0026gt;) # Returns indices of all colliding Rects. Surface     Object for representing images.\n\u0026lt;Surf\u0026gt; = pg.display.set_mode((width, height)) # Returns the display surface. \u0026lt;Surf\u0026gt; = pg.Surface((width, height)) # Creates a new surface. \u0026lt;Surf\u0026gt; = pg.image.load(\u0026#39;\u0026lt;path\u0026gt;\u0026#39;) # Loads the image. \u0026lt;Surf\u0026gt; = \u0026lt;Surf\u0026gt;.subsurface(\u0026lt;Rect\u0026gt;) # Returns a subsurface. \u0026lt;Surf\u0026gt;.fill(color) # Fills the whole surface. \u0026lt;Surf\u0026gt;.set_at((x, y), color) # Updates pixel. \u0026lt;Surf\u0026gt;.blit(\u0026lt;Surface\u0026gt;, (x, y)) # Draws passed surface to the surface. \u0026lt;Surf\u0026gt; = pg.transform.flip(\u0026lt;Surf\u0026gt;, xbool, ybool) \u0026lt;Surf\u0026gt; = pg.transform.rotate(\u0026lt;Surf\u0026gt;, degrees) \u0026lt;Surf\u0026gt; = pg.transform.scale(\u0026lt;Surf\u0026gt;, (width, height)) pg.draw.line(\u0026lt;Surf\u0026gt;, color, (x1, y1), (x2, y2), width) pg.draw.arc(\u0026lt;Surf\u0026gt;, color, \u0026lt;Rect\u0026gt;, from_radians, to_radians) pg.draw.rect(\u0026lt;Surf\u0026gt;, color, \u0026lt;Rect\u0026gt;) pg.draw.polygon(\u0026lt;Surf\u0026gt;, color, points) pg.draw.ellipse(\u0026lt;Surf\u0026gt;, color, \u0026lt;Rect\u0026gt;) Font     \u0026lt;Font\u0026gt; = pg.font.SysFont(\u0026#39;\u0026lt;name\u0026gt;\u0026#39;, size, bold=False, italic=False) \u0026lt;Font\u0026gt; = pg.font.Font(\u0026#39;\u0026lt;path\u0026gt;\u0026#39;, size) \u0026lt;Surf\u0026gt; = \u0026lt;Font\u0026gt;.render(text, antialias, color, background=None) Sound     \u0026lt;Sound\u0026gt; = pg.mixer.Sound(\u0026#39;\u0026lt;path\u0026gt;\u0026#39;) # Loads the WAV file. \u0026lt;Sound\u0026gt;.play() # Starts playing the sound. Basic Mario Brothers Example     import collections, dataclasses, enum, io, pygame, urllib.request, itertools as it from random import randint  P = collections.namedtuple(\u0026#39;P\u0026#39;, \u0026#39;x y\u0026#39;) # Position D = enum.Enum(\u0026#39;D\u0026#39;, \u0026#39;n e s w\u0026#39;) # Direction SIZE, MAX_SPEED = 50, P(5, 10) # Screen size, Speed limit  def main():  def get_screen():  pygame.init()  return pygame.display.set_mode(2 * [SIZE*16])  def get_images():  url = \u0026#39;https://gto76.github.io/python-cheatsheet/web/mario_bros.png\u0026#39;  img = pygame.image.load(io.BytesIO(urllib.request.urlopen(url).read()))  return [img.subsurface(get_rect(x, 0)) for x in range(img.get_width() // 16)]  def get_mario():  Mario = dataclasses.make_dataclass(\u0026#39;Mario\u0026#39;, \u0026#39;rect spd facing_left frame_cycle\u0026#39;.split())  return Mario(get_rect(1, 1), P(0, 0), False, it.cycle(range(3)))  def get_tiles():  positions = [p for p in it.product(range(SIZE), repeat=2) if {*p} \u0026amp; {0, SIZE-1}] + \\  [(randint(1, SIZE-2), randint(2, SIZE-2)) for _ in range(SIZE**2 // 10)]  return [get_rect(*p) for p in positions]  def get_rect(x, y):  return pygame.Rect(x*16, y*16, 16, 16)  run(get_screen(), get_images(), get_mario(), get_tiles())  def run(screen, images, mario, tiles):  clock = pygame.time.Clock()  while all(event.type != pygame.QUIT for event in pygame.event.get()):  keys = {pygame.K_UP: D.n, pygame.K_RIGHT: D.e, pygame.K_DOWN: D.s, pygame.K_LEFT: D.w}  pressed = {keys.get(i) for i, on in enumerate(pygame.key.get_pressed()) if on}  update_speed(mario, tiles, pressed)  update_position(mario, tiles)  draw(screen, images, mario, tiles, pressed)  clock.tick(28)  def update_speed(mario, tiles, pressed):  x, y = mario.spd  x += 2 * ((D.e in pressed) - (D.w in pressed))  x -= x / abs(x) if x else 0  y += 1 if D.s not in get_boundaries(mario.rect, tiles) else (-10 if D.n in pressed else 0)  mario.spd = P(*[max(-limit, min(limit, s)) for limit, s in zip(MAX_SPEED, P(x, y))])  def update_position(mario, tiles):  old_p, delta = mario.rect.topleft, P(0, 0)  larger_speed = max(abs(s) for s in mario.spd)  for _ in range(int(larger_speed)):  mario.spd = stop_on_collision(mario.spd, get_boundaries(mario.rect, tiles))  delta = P(*[a + s/larger_speed for a, s in zip(delta, mario.spd)])  mario.rect.topleft = [sum(pair) for pair in zip(old_p, delta)]  def get_boundaries(rect, tiles):  deltas = {D.n: P(0, -1), D.e: P(1, 0), D.s: P(0, 1), D.w: P(-1, 0)}  return {d for d, delta in deltas.items() if rect.move(delta).collidelist(tiles) != -1}  def stop_on_collision(spd, bounds):  return P(x=0 if (D.w in bounds and spd.x \u0026lt; 0) or (D.e in bounds and spd.x \u0026gt; 0) else spd.x,  y=0 if (D.n in bounds and spd.y \u0026lt; 0) or (D.s in bounds and spd.y \u0026gt; 0) else spd.y)  def draw(screen, images, mario, tiles, pressed):  def get_frame_index():  if D.s not in get_boundaries(mario.rect, tiles):  return 4  return next(mario.frame_cycle) if {D.w, D.e} \u0026amp; pressed else 6  screen.fill((85, 168, 255))  mario.facing_left = (D.w in pressed) if {D.e, D.w} \u0026amp; pressed else mario.facing_left  screen.blit(images[get_frame_index() + mario.facing_left * 9], mario.rect)  for rect in tiles:  screen.blit(images[18 if {*rect.topleft} \u0026amp; {0, (SIZE-1)*16} else 19], rect)  pygame.display.flip()  if __name__ == \u0026#39;__main__\u0026#39;:  main() Basic Script Template     #!/usr/bin/env python3 # # Usage: .py #  from collections import namedtuple from dataclasses import make_dataclass from enum import Enum from sys import argv import re   def main():  pass   ### ## UTIL #  def read_file(filename):  with open(filename, encoding=\u0026#39;utf-8\u0026#39;) as file:  return file.readlines()   if __name__ == \u0026#39;__main__\u0026#39;:  main() "},{"id":9,"href":"/posts/markdown/","title":"MarkDown 语法规则参考","parent":"Posts","content":"一、标题     # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 效果如下：\n这是一级标题     这是二级标题     这是三级标题     这是四级标题     这是五级标题     这是六级标题     二、字体     ### **加粗** #### 要加粗的文字左右分别用两个*号包起来 ### *斜体* #### 要倾斜的文字左右分别用一个*号包起来 ### ***斜体加粗*** #### 要倾斜和加粗的文字左右分别用三个*号包起来 ### ~~删除线~~ #### 要加删除线的文字左右分别用两个~~号包起来 ### `高亮` #### 要加高亮的文字左右分别用两个``号包起来 效果如下：\n这是加粗的文字\n这是倾斜的文字\n这是斜体加粗的文字\n这是加删除线的文字\n网络编程\n三、引用     \u0026gt;这是引用的内容 \u0026gt;\u0026gt;这是引用的内容 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;这是引用的内容 效果如下：\n 这是引用的内容\n 这是引用的内容\n 这是引用的内容\n   四、分割线     --- ---- *** ***** 效果如下：        五、图片     ![图片alt](图片地址 \u0026#34;图片title\u0026#34;)  图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加  ![blockchain](./mywechat.jpg \u0026#34;区块链\u0026#34;) 效果如下： 六、超链接     [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) title可加可不加  [简书](http://jianshu.com) [百度](http://baidu.com) 效果如下： 简书 百度\n七、列表     ##### 无序列表： - 列表内容 + 列表内容 * 列表内容  注意：- + * 跟内容之间都要有一个空格 效果如下：\n  列表内容   列表内容   列表内容  ##### 有序列表： 1.列表内容 2.列表内容 3.列表内容 效果如下： 1.列表内容\n2.列表内容\n3.列表内容\n##### 列表嵌套： 一级无序列表内容  二级有序列表内容 二级有序列表内容 二级有序列表内容 效果如下： 一级无序列表内容\n1.级有序列表内容\n2.级有序列表内容\n3.级有序列表内容\n八、表格     表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容  第二行分割表头和内容。\n  有一个就行，为了对齐，多加了几个\n文字默认居左\n-两边加：表示文字居中\n-右边加：表示文字居右   注：原生的语法两边都要用 | 包起来。此处省略\n 效果如下：\n   姓名 技能 排行     刘备 哭 大哥   关羽 打 二哥   张飞 骂 三弟    九、代码      ```python  code code code  code code  code code  ``` 效果如下：\ncode code code  code code  code code 十、其他      换行 ，空两格就会换行  "},{"id":10,"href":"/posts/kafka/","title":"Kafka","parent":"Posts","content":"介绍     一个分布式、分区的、多副本的、多订阅者的基于zookeeper协调的消息队列系统\n名词解释      Topic 发布到Kafka集群的消息的类别，类似于数据库的表名 broker 服务器节点 partition topic中的数据分割为一个或多个patition , 至少有一个 producer 生产者 consumer 消费者  常用命令      启动kafaka\nbin/kafka-server-start.sh config/server.properties 创建主题\nbin/kafka-topics.sh --create --zookeeper hadoop101:2181 --partitions 1 --replication-factor 1 --topic first\nbin/kafka-topics.sh --create --partitions 1 --replication-factor 1 --topic first --bootstrap-server 127.0.0.1:9092 查看主题\nbin/kafka-topics.sh --list --zookeeper hadoop101:2181 删除主题\nbin/kafka-topics.sh --zookeeper hadoop101:2181 --delete --topic first 发送消息\nbin/kafka-console-producer.sh --broker-list hadoop101:9092 --topic first 消费消息\nbin/kafka-console-consumer.sh --zookeeper hadoop101:2181 --topic first  bin/kafka-console-consumer.sh --zookeeper hadoop101:2181 --topic first --from-beginning  "},{"id":11,"href":"/posts/istio/","title":"Istio","parent":"Posts","content":"1、其他      HPA VPA  2、Consul     3、Eureka     4、Zipkin     5、微服务架构      dubbo springCloud  6、Knative     serviceless\n7、Istio     与Kubernetes紧密结合的适用于云原生场景的Service Mesh形态的用于服务治理的开发平台。\n服务治理：连接、安全、策略执行、可观测性\n UDPA(Universal Data Plane API)\n数据平面标准\u0026mdash;-实例间网络流量 SMI(Service Mesh Interface)\n制平面标准\u0026mdash;-负责生成和部署控制数据平面行为的相关配置  7.1、Pilot     配置数据 VirtualService DestinationRule Gateway ServiceEntry\n gRPC xDS  7.2、Envoy     Service Mesh 服务网格，专注于处理服务间通信的基础设施，云原生组成的复杂拓扑中可靠的传递请求\nEnvoy 服务网格的数据面代理 动态服务发现、负载均衡、TLS、HTTP/2、gRPC代理、等等的实现角色\n7.3、Mixer      telemetry 数据收集 policy 策略执行，访问控制 对接配额、授权、黑白名单的控制后端  7.4、citadel     安全组件 证书、密钥 tls认证、访问授权、通道加密\n7.5、galley     控制面 配置管理\n7.6、sidecar-injector     自动注入sidecar\n7.7proxy     "},{"id":12,"href":"/posts/bigdata/","title":"BigData","parent":"Posts","content":"Hadoop     分布式系统基础架构,Hadoop实现了一个分布式文件系统（ Distributed File System），其中一个组件是HDFS（Hadoop Distributed File System）\nHDFS有着高容错性（fault-tolerant）的特点，并且设计用来部署在低廉的（low-cost）硬件上。而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求（requirements）这样可以实现流的形式访问（streaming access）文件系统中的数据\n包含的Modules      Hadoop Common: The common utilities that support the other Hadoop modules. Hadoop Distributed File System (HDFS™): A distributed file system that provides high-throughput access to application data. Hadoop YARN: A framework for job scheduling and cluster resource management. Hadoop MapReduce: A YARN-based system for parallel processing of large data sets.  Hadoop框架     HDFS （存储） 和 MapReduce （计算）\nJobtracker | Tasktracker | MapReduce Job     主节点 | 工作节点 | 作业\nYARN     通用资源管理系统，为上层提供统一的资源管理和调度。\n基本思想是将JobTracker的两个主要功能（资源管理和作业调度/监控）分离，主要方法是创建一个全局的ResourceManager（RM）和若干个针对应用程序的ApplicationMaster（AM）。这里的应用程序是指传统的MapReduce作业或作业的DAG（有向无环图）\nETL     提取 变形 加载\nPig     A high-level data-flow language and execution framework for parallel computation\nHive      数据仓库工具 ，实现ETL 蒋SQL语句转变为MapReduce任务执行 数据仓库进行统计分析 不适合联机（online）事物处理、不能实时查询 最佳使用场合是大数据集的批处理作业，例如，网络日志分析  Hbase     分布式数据库，面向列的，适用于非结构化数据存储,导入性能只有大约2000条/秒\nMapReduce     软件框架\nStorm     实时版Hadoop,流处理框架，适用：\n 比如网站统计(实时销量、流量统计，如淘宝双11效果图) 推荐系统(实时推荐，根据下单或加入购物车推荐相关商品) 预警系统 金融系统(高频交易、股票)等等  at-least-once     Nimbus | Supervisor | topologies     主节点 | 工作节点 | 作业\nSpark     统一流处理和批处理的框架 一切都是批次\n 大规模数据处理的计算引擎 启用了内存分布数据集 适用于数据挖掘与机器学习等需要迭代的MapReduce的算法  Flink     统一流数据处理与批处理的框架,流处理速度比Storm 快，提供更高级的api，一切都是流\n 批处理和Spark非常相似 流处理和Spark不同，和Storm很相似  exactly-once     Doris     MPP(大规模并行)分析型数据库产品(亚秒级响应),有效地支持实时数据分析,支持10PB以上的超大数据集\nMesos     分布式资源管理框架，分布式系统内核\n如果把数据中心中的集群资源看做一台服务器，那么Mesos要做的事情，其实就是今天操作系统内核的职责：抽象资源+调度任务\n常见的集群资源管理器     Hadoop YARN、 Apache Mesos 、Kubernetes\n服务发现框架     Eureka(spring cloud) consule Zookeeper Nacos\nCAP理论     CAP理论是分布式架构中重要理论\n 一致性(Consistency) (所有节点在同一时间具有相同的数据) 可用性(Availability) (保证每个请求不管成功或者失败都有响应) 分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)  "},{"id":13,"href":"/categories/","title":"Categories","parent":"Jimywu's Hugo Site","content":""},{"id":14,"href":"/tags/","title":"Tags","parent":"Jimywu's Hugo Site","content":""}]